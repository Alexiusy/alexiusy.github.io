<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Builder pattern 在 iOS 中的实践</title>
      <link href="/2023/06/12/Builder-pattern-%E5%9C%A8-iOS-%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/06/12/Builder-pattern-%E5%9C%A8-iOS-%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>和其它设计模式一样，建造者模式的目的是为了减少可变状态的需求，使得结果是可预测的。因为建造者模式的是由纯粹的输入和输出构建起来的，因此也就更加易于测试和调试。</p><h3 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h3><p>建造者模式的核心就是使用一个专门的建造者类型来构建对象。比如说，要创建一个图标加文本的按钮，常见的写法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button <span class="operator">=</span> <span class="type">UIButton</span>()</span><br><span class="line">button.setimage(<span class="type">UIImage</span>(named: <span class="string">&quot;icon&quot;</span>), for: .normal)</span><br><span class="line">button.setTitle(<span class="string">&quot;Hello&quot;</span>, for: .normal)</span><br></pre></td></tr></table></figure><p>而如果采用建造者模式的话，代码就会变成如下这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button <span class="operator">=</span> <span class="type">ButtonBuilder</span>()</span><br><span class="line">    .title(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    .image(<span class="type">UIImage</span>(named: <span class="string">&quot;icon&quot;</span>))</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，通过 <code>ButtonBuilder</code> 调用一系列的链式方法调用设置所有的属性，并且在最后调用 <code>build</code> 方法创建按钮实例。每次的链式调用都会返回 <code>ButtonBuilder</code> 本身，这样就会更容易地在不引入另外的本地变量的情况下实现链式调用。</p><h3 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h3><p>建造者模式有两个主要的优点。</p><h4 id="1-隐藏属性"><a href="#1-隐藏属性" class="headerlink" title="1. 隐藏属性"></a>1. 隐藏属性</h4><p>因为引入了 builder 类型，因此可以将原本的对象的部分属性和方法隐藏起来使外部无法直接访问。这样可以让视图变得更简洁，也不需要针对内容的变化产生响应。</p><h4 id="2-阻止状态共享"><a href="#2-阻止状态共享" class="headerlink" title="2. 阻止状态共享"></a>2. 阻止状态共享</h4><p>建造者模式可以防止共享可变状态。这是什么意思呢？举个例子，如果需要将用户的输入转换为富文本显示在屏幕上，常见的做法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextViewController</span>: <span class="title class_">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> text: <span class="type">NSMutableAttributedString</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">appendString</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> attrString <span class="operator">=</span> <span class="type">NSMutableAttributedString</span>(string: string, attributes: textAttributes)</span><br><span class="line"></span><br><span class="line">        text.append(attrString)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">drawing</span>() &#123;</span><br><span class="line">        <span class="comment">// 将text绘制到屏幕上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看上去没有问题，但是，如果在绘制的时候，<code>text</code> 发生了改变，则最终显示在屏幕上的内容与预期的并不一致，这便是可变状态共享可能造成的问题。<br>如果使用建造者模式，那么状态共享的问题便可以得到解决。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AttributedStringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Attributes</span> <span class="operator">=</span> [<span class="type">NSAttributedStringKey</span> : <span class="keyword">Any</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> text <span class="operator">=</span> <span class="type">NSMutableAttributedString</span>(string: <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>, <span class="params">attributes</span>: <span class="type">Attributes</span>) -&gt; <span class="type">AttributedStringBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> attrString <span class="operator">=</span> <span class="type">NSAttributedString</span>(string: string, attributes: attributes)</span><br><span class="line">        text.append(attrString)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">build</span>() -&gt; <span class="type">NSAttributedString</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSAttributedString</span>(attributedString: text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextViewController</span>: <span class="title class_">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> textBuilder <span class="operator">=</span> <span class="type">AttributedStringBuilder</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">appendString</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        textBuilder.append(string, attributes: textAttributes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">drawing</span>() &#123;</span><br><span class="line">        <span class="comment">// 将text绘制到屏幕上</span></span><br><span class="line">        <span class="keyword">let</span> text <span class="operator">=</span> textBuilder.build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引入建造者模式之后，由于在绘制的时候才会生成最后的富文本，用户改变的内容将不会影响到已经生成的富文本，因此也成功地阻止了可变状态的共享所产生的负面影响。</p><h3 id="屏蔽复杂度"><a href="#屏蔽复杂度" class="headerlink" title="屏蔽复杂度"></a>屏蔽复杂度</h3><p>建造者模式也可以为复杂任务提供简单的API。按照个人的理解，这与系统提供的高阶函数如<code>map</code>，<code>filter</code>等非常类似，就是将所有的操作通过链式调用组合起来。在此处便不再赘述了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 14.3打包失败问题</title>
      <link href="/2023/05/03/Xcode-14-3%E6%89%93%E5%8C%85%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/03/Xcode-14-3%E6%89%93%E5%8C%85%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近升级了Xcode 14.3，要打包提审的时候发现打包失败了，build run这些都是正常的。看了看报错信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PhaseScriptExecution [CP] Embed Pods Frameworks</span><br><span class="line">...</span><br><span class="line">failed: No such file or directory.</span><br></pre></td></tr></table></figure><p>从错误信息可以看出，是在执行Cocoapods脚本的阶段出现了错误，找不到对应的库了。这在未升级 Xcode 之前是没有出现过的。所以首先想到的就是 Xcode 的bug。但是这也没办法去改，所以最直接的办法就是降版本，把Xcode退回到14.2，问题就解决了。</p><p>后来在苹果的论坛里面看到有人也遇到了同样的问题，有人提出了解决方案是更新所有生成的 xxx-frameworks.sh 文件，将 -f 标志添加到对 readlink 的调用。具体的操作方法就是修改项目中 Pods -&gt; Targets Support Files -&gt; Pods-XXX -&gt; Pods-XXX-frameworks 中的第44行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改前</span></span><br><span class="line">source=&quot;$(readlink &quot;$&#123;source&#125;&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改后</span></span><br><span class="line">source=&quot;$(readlink -f &quot;$&#123;source&#125;&quot;)&quot;</span><br></pre></td></tr></table></figure><p>经过尝试，在Xcode14.3下也能正常打包了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xcode </tag>
            
            <tag> Cocoapods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现实时活动和灵动岛</title>
      <link href="/2022/09/15/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E6%B4%BB%E5%8A%A8%E5%92%8C%E7%81%B5%E5%8A%A8%E5%B2%9B/"/>
      <url>/2022/09/15/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E6%B4%BB%E5%8A%A8%E5%92%8C%E7%81%B5%E5%8A%A8%E5%B2%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1 概览"></a>1 概览</h3><p>实时活动是在 iOS 16.1 上面推出的新 API，用于在锁屏和灵动岛上显示最新数据。为了实现实时活动，需要在小部件实现。实时活动使用 WidgetKit 和 SwiftUI 来构建用户界面，而 ActivityKit 则用于处理实时活动的生命周期——请求、更新、和结束。</p><h3 id="2-实时活动的要求和限制"><a href="#2-实时活动的要求和限制" class="headerlink" title="2 实时活动的要求和限制"></a>2 实时活动的要求和限制</h3><p>实时活动最多能保持 8 小时，超过时系统会自动结束。当实时活动结束时，会从灵动岛上移除，但是会留在锁屏上最多 4 小时。因此理论上来说，实时活动可以在锁屏上最多保留 12 小时。<br>实时活动运行在独立的沙盒中，不能像小部件一样访问网络或者接收定位更新。所以只能在应用中使用 ActivityKit 或者远程推送通知来刷新活动的数据。</p><blockquote><p><strong>注意</strong><br>不论使用何种方式更新，其数据的大小不能超过 4KB。</p></blockquote><h3 id="3-为应用添加实时活动支持"><a href="#3-为应用添加实时活动支持" class="headerlink" title="3 为应用添加实时活动支持"></a>3 为应用添加实时活动支持</h3><p>添加实时活动只需要如下几步：</p><ol><li>创建小组件，如果应用中已存在小组件，略过。</li><li>在主应用的 Info.plist 文件中添加实时活动的支持，设置Supports Live Activities 为 YES。</li><li>添加 ActivityAttributes 来描述实时活动的数据。</li><li>使用 ActivityAttributes 创建 ActivityConfiguration。</li><li>实现实时活动的启动、更新和结束的功能。</li></ol><p>此处略过1、2步。</p><h4 id="3-1-定义活动数据类型"><a href="#3-1-定义活动数据类型" class="headerlink" title="3.1 定义活动数据类型"></a>3.1 定义活动数据类型</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FitnessAttributes</span>: <span class="title class_">ActivityAttributes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ContentState</span> <span class="operator">=</span> <span class="type">FitnessState</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">FitnessState</span>: <span class="title class_">Codable</span>, <span class="title class_">Hashable</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> item: <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> time: <span class="type">ClosedRange</span>&lt;<span class="type">Date</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> fitnessGoal: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个健身的实时活动 attributes。其中，FitnessAttributes 中定义的为静态数据类型，而 FitnessState 中所定义的则为动态数据类型。</p><h4 id="3-2-创建实时活动的视图"><a href="#3-2-创建实时活动的视图" class="headerlink" title="3.2 创建实时活动的视图"></a>3.2 创建实时活动的视图</h4><p>有了实时活动所需的数据类型，接下来就是在灵动岛和锁屏上将其显示出来。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FitnessWidget</span>: <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">WidgetConfiguration</span> &#123;</span><br><span class="line">        <span class="type">ActivityConfiguration</span>(for: <span class="type">FitnessAttributes</span>.<span class="keyword">self</span>) &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="type">FitnessLockScreenView</span>(context: context)</span><br><span class="line">        &#125; dynamicIsland: &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="type">DynamicIsland</span> &#123;</span><br><span class="line">                <span class="type">DynamicIslandExpandedRegion</span>(.center) &#123;</span><br><span class="line">                    <span class="type">Text</span>(context.attributes.username <span class="operator">+</span> <span class="string">&quot;正在&quot;</span> <span class="operator">+</span> context.state.item <span class="operator">+</span> <span class="string">&quot;！&quot;</span>)</span><br><span class="line">                    <span class="type">Label</span> &#123;</span><br><span class="line">                        <span class="type">Text</span>(timerInterval: context.state.time, countsDown: <span class="literal">true</span>)</span><br><span class="line">                    &#125; icon: &#123;</span><br><span class="line">                        <span class="type">Image</span>(systemName: <span class="string">&quot;timer&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    .font(.title2)</span><br><span class="line">                    .foregroundColor(.orange)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; compactLeading: &#123;</span><br><span class="line">                <span class="type">CompactLeadingView</span>(context: context)</span><br><span class="line">            &#125; compactTrailing: &#123;</span><br><span class="line">                <span class="type">CompactTrailingView</span>(context: context)</span><br><span class="line">            &#125; minimal: &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;figure.step.training&quot;</span>)</span><br><span class="line">                    .foregroundColor(.white)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就来看看以上代码具体是什么意思。</p><p>首先是构造一个实时活动的配置并返回，这个方法的签名如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Content</span>&gt;(<span class="params">for</span> <span class="params">attributesType</span>: <span class="type">Attributes</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">Attributes</span>.<span class="keyword">self</span>, <span class="meta">@ViewBuilder</span> <span class="params">content</span>: <span class="keyword">@escaping</span> (<span class="type">ActivityViewContext</span>&lt;<span class="type">Attributes</span>&gt;) -&gt; <span class="type">Content</span>, <span class="params">dynamicIsland</span>: <span class="keyword">@escaping</span> (<span class="type">ActivityViewContext</span>&lt;<span class="type">Attributes</span>&gt;) -&gt; <span class="type">DynamicIsland</span>) <span class="keyword">where</span> <span class="type">Content</span> : <span class="type">View</span></span><br></pre></td></tr></table></figure><p>方法签名虽然看起来很长，但实际上只有三个参数，第一个是支持的实时活动的数据类型，也就是前文定义的 ActivityAttributes。第二个参数是个闭包，用于构建锁屏状态下的实时活动视图。第三个参数同样是个闭包，用于构建灵动岛的视图。</p><p>前面两个参数都比较简单，一看就会用，这里主要讲一讲灵动岛的实现。</p><p>灵动岛由 DynamicIsland 进行初始化，看一下初始化的方法签名：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Expanded</span>, <span class="type">CompactLeading</span>, <span class="type">CompactTrailing</span>, <span class="type">Minimal</span>&gt;(<span class="meta">@DynamicIslandExpandedContentBuilder</span> <span class="params">expanded</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Expanded</span>, <span class="meta">@ViewBuilder</span> <span class="params">compactLeading</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">CompactLeading</span>, <span class="meta">@ViewBuilder</span> <span class="params">compactTrailing</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">CompactTrailing</span>, <span class="meta">@ViewBuilder</span> <span class="params">minimal</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Minimal</span>) <span class="keyword">where</span> <span class="type">Expanded</span> : <span class="type">DynamicIslandExpandedContent</span>, <span class="type">CompactLeading</span> : <span class="type">View</span>, <span class="type">CompactTrailing</span> : <span class="type">View</span>, <span class="type">Minimal</span> : <span class="type">View</span></span><br></pre></td></tr></table></figure><p>一共有四个闭包，分别是：</p><ul><li>Expanded，代表了灵动岛展开时的视图；</li><li>CompactLeading，代表摄像头之前的视图；</li><li>CompactTrailing，代表摄像头之后的视图；</li><li>Minimal，存在多个实时活动时的视图；</li></ul><p>后三个都是常见的 SwiftUI 视图，Expanded 中需要根据对应的区域来构建不同的视图。<br>如开发者官网文档的图片所示：<br><img src="https://docs-assets.developer.apple.com/published/e7011a56e8cf175d1f6aba25a417c19a/live-activity-leading-trailing~dark@2x.png" alt="灵动岛显示区域划分"></p><p>展开的视图分为四个区域，分别为 leading、trailing、center 和 bottom。所以在构建视图的时候根据需要显示的内容设置不同的视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DynamicIslandExpandedRegion</span>(.center) &#123;</span><br><span class="line"><span class="type">Text</span>(context.attributes.username <span class="operator">+</span> <span class="string">&quot;正在&quot;</span> <span class="operator">+</span> context.state.item <span class="operator">+</span> <span class="string">&quot;！&quot;</span>)</span><br><span class="line"><span class="type">Label</span> &#123;</span><br><span class="line"><span class="type">Text</span>(timerInterval: context.state.time, countsDown: <span class="literal">true</span>)</span><br><span class="line">&#125; icon: &#123;</span><br><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;timer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.font(.title2)</span><br><span class="line">.foregroundColor(.orange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实现了灵动岛展开情况下中间部分的视图，其余几个部分都大同小异。另外需要说明的是，当左右两边的空间不够时，可以使用 <code>belowIfTooWide</code> 修饰符将其内容显示在摄像头下方，但是这一条在实际使用时并没有生效，不知是使用方式的问题还是苹果的bug。</p><p>同样借用官网的图来表示左右两边的视图可以占据的最大空间。<br><img src="https://docs-assets.developer.apple.com/published/0ac0cab042731faf4f7e9df18ac47283/live-activity-leading-expanded~dark@2x.png" alt="灵动岛优先级展示"></p><h3 id="4-实时活动的创建、更新与结束"><a href="#4-实时活动的创建、更新与结束" class="headerlink" title="4. 实时活动的创建、更新与结束"></a>4. 实时活动的创建、更新与结束</h3><h4 id="4-1-创建"><a href="#4-1-创建" class="headerlink" title="4.1 创建"></a>4.1 创建</h4><p>为了创建实时活动，首先需要创建实时活动所需要的数据，注意，动态数据和静态数据要分别创建。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> future <span class="operator">=</span> <span class="type">Calendar</span>.current.date(byAdding: .minute, value: <span class="number">20</span>, to: <span class="type">Date</span>())<span class="operator">!</span></span><br><span class="line"><span class="keyword">let</span> date <span class="operator">=</span> <span class="type">Date</span>.now<span class="operator">...</span>future</span><br><span class="line"><span class="keyword">let</span> fitnessAttributes <span class="operator">=</span> <span class="type">FitnessAttributes</span>(username: <span class="string">&quot;Ludwig&quot;</span>, fitnessGoal: <span class="string">&quot;早日回到BMI正常区间。&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> fitnessState <span class="operator">=</span> <span class="type">FitnessAttributes</span>.<span class="type">FitnessState</span>(item: <span class="string">&quot;跑步&quot;</span>, time: date)</span><br></pre></td></tr></table></figure><p>然后使用 Activity 类就可以轻松地创建实时活动了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">let</span> fitnessActivity <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Activity</span>.request(attributes: fitnessAttributes, contentState: fitnessState)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Created a fitness activity <span class="subst">\(String(describing: fitnessActivity<span class="operator">?</span>.id))</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-更新"><a href="#4-2-更新" class="headerlink" title="4.2 更新"></a>4.2 更新</h4><p>更新则只需要创建一个新的动态数据，然后将其设置到实时活动就行了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> future <span class="operator">=</span> <span class="type">Calendar</span>.current.date(byAdding: .minute, value: <span class="number">10</span>, to: <span class="type">Date</span>())<span class="operator">!</span></span><br><span class="line"><span class="keyword">let</span> date <span class="operator">=</span> <span class="type">Date</span>.now<span class="operator">...</span>future</span><br><span class="line"><span class="keyword">let</span> fitnessState <span class="operator">=</span> <span class="type">FitnessAttributes</span>.<span class="type">FitnessState</span>(item: <span class="string">&quot;跑步&quot;</span>, time: date)</span><br><span class="line"><span class="keyword">let</span> alertConfiguration <span class="operator">=</span> <span class="type">AlertConfiguration</span>(title: <span class="string">&quot;Fitness update&quot;</span>, body: <span class="string">&quot;10 minutes left&quot;</span>, sound: .default)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> fitnessActivity<span class="operator">?</span>.update(using: fitnessState, alertConfiguration: alertConfiguration)</span><br></pre></td></tr></table></figure><p>需要注意的是，更新的同时，还会有一个提示，提示的声音既可以使用默认的，也可以自定义。</p><p>在后台更新可以参考使用 [[BackgroundTasks 实践#^a71227|BackgroundTasks]] 来做。</p><h4 id="4-3-结束"><a href="#4-3-结束" class="headerlink" title="4.3 结束"></a>4.3 结束</h4><p>结束就更简单了，需要传递两个参数。<br>第一个参数是动态数据，也就是实时活动结束时你想让它处于什么样的状态，那么这里就设置成什么样的数据。<br>第二个参数是结束时的策略，有三种可选：</p><ol><li>default，如果用户不手动清除屏幕上的实时活动，则系统会在四小时后自动清除；</li><li>immediate，就是在活动结束时马上清除实时活动；</li><li>after，需要提供一个日期，在这个时间到来时清除实时活动，此日期不能超过现在的四小时，超过的话，以四小时计。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> fitnessActivity<span class="operator">?</span>.end(using: fitnessState, dismissalPolicy: .default)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>注意</strong><br>需要注意的是，更新和结束都可以在后台执行，具体执行的方法参考 <code>Background Task</code> 。</p></blockquote><p>以上就是关于实时活动和灵动岛的全部内容了，后面再写利用远程通知来更新或结束实时活动的内容。</p><blockquote><p><strong>参考文章</strong><br><a href="https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities">官网文档</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时活动 </tag>
            
            <tag> 灵动岛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Moya 在用户 token 失效情况下的请求重试</title>
      <link href="/2022/03/17/Moya-%E5%9C%A8%E7%94%A8%E6%88%B7-token-%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E8%AF%B7%E6%B1%82%E9%87%8D%E8%AF%95/"/>
      <url>/2022/03/17/Moya-%E5%9C%A8%E7%94%A8%E6%88%B7-token-%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E8%AF%B7%E6%B1%82%E9%87%8D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>公司的一个项目中的所有 API 接口无论是否登录都要带一个 token，如果没有 token 的话请求就会失败，因此在没有 token 或者是 token 失效的情况下要调用获取 token 的 API 将获取到的 token 存储到本地。</p><h3 id="多次调用接口"><a href="#多次调用接口" class="headerlink" title="多次调用接口"></a>多次调用接口</h3><p>写完代码后一测试，后台发现用户数量呈不正常的状态在增长，一查，发现每请求一次 token 都会生成一个用户。那么只能限制获取 token 的接口的调用次数了，一旦获取到 token，后续请求 token 的接口都取消。很自然地就想到用 OperationQueue 来做这个事情。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> operationQueue: <span class="type">OperationQueue</span> <span class="operator">=</span> &#123;</span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line">queue.maxConcurrentOperationCount <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> queue</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getAccesstoken</span>() &#123;</span><br><span class="line">operationQueue.addOperation &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> this <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">this.getToken()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getToken</span>() &#123;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handleResult</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">String</span>) &#123;</span><br><span class="line"><span class="comment">// 取消排队等候的所有请求</span></span><br><span class="line">operationQueue.cancelAllOperations()</span><br><span class="line">group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handleError</span>(<span class="keyword">_</span> <span class="params">error</span>: <span class="type">Error</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line"></span><br><span class="line">webService.getToken()</span><br><span class="line">.done(handleResult)</span><br><span class="line">.catch(handleError)</span><br><span class="line"></span><br><span class="line">group.wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了多次调用获取 token 请求的问题。</p><h3 id="Moya-重试请求"><a href="#Moya-重试请求" class="headerlink" title="Moya 重试请求"></a>Moya 重试请求</h3><p>在 token 失效之后还得解决一个问题，那就是由于 token 失效导致的请求失败的问题，得让失败的请求进行重试，由于用的是 Moya 框架，搜索了许多重试的解决方案，无奈的是试过之后都不起作用，最后只能自己子类化一个 provider 来实现重试的功能。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomProvider</span>&lt;<span class="title class_">T</span>: <span class="title class_">TargetType</span>&gt;: <span class="title class_">MoyaProvider</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">request</span>(<span class="keyword">_</span> <span class="params">target</span>: <span class="type">T</span>, <span class="params">callbackQueue</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> .none, <span class="params">progress</span>: <span class="type">ProgressBlock</span>? <span class="operator">=</span> .none, <span class="params">completion</span>: <span class="keyword">@escaping</span> <span class="type">Completion</span>) -&gt; <span class="type">Cancellable</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.request(target, callbackQueue: callbackQueue, progress: progress) &#123; result <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> result &#123;</span><br><span class="line">            <span class="keyword">case</span> .success(<span class="keyword">let</span> response):</span><br><span class="line">                <span class="comment">// 获取 token 失效时的业务状态码</span></span><br><span class="line">                <span class="operator">...</span></span><br><span class="line">                <span class="keyword">if</span> statusCode <span class="operator">==</span> xxx &#123;</span><br><span class="line">                    <span class="comment">// 重发请求</span></span><br><span class="line">                    <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.network.retry&quot;</span>, attributes: .concurrent)</span><br><span class="line">                    queue.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">self</span>.request(target, callbackQueue: callbackQueue, progress: progress, completion: completion)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    completion(.success(response))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">                completion(.failure(error))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Moya </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UILabel超过指定行数时显示更多</title>
      <link href="/2021/12/17/UILabel%E8%B6%85%E8%BF%87%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%95%B0%E6%97%B6%E6%98%BE%E7%A4%BA%E6%9B%B4%E5%A4%9A/"/>
      <url>/2021/12/17/UILabel%E8%B6%85%E8%BF%87%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%95%B0%E6%97%B6%E6%98%BE%E7%A4%BA%E6%9B%B4%E5%A4%9A/</url>
      
        <content type="html"><![CDATA[<p>在开发中经常会碰到只显示少量介绍文字，点击更多的时候才会查看更多全部内容，如何在不使用第三方库的情况下准确地在行末加上“更多”的文字呢？</p><p>我们可以为 <code>UILabel</code> 添加扩展方法来实现。</p><h3 id="1-获取每一行的文字数组"><a href="#1-获取每一行的文字数组" class="headerlink" title="1. 获取每一行的文字数组"></a>1. 获取每一行的文字数组</h3><p>首先，获取每一行的文本，目的有两个，第一是判断文本行数是否超过了指定的行数，第二是为了获取最后一行文本以拼接“更多”的字符串。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 获取 Label 每行内容 得到一个数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">getLines</span>(<span class="params">fitWidth</span>: <span class="type">CGFloat</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> text <span class="operator">=</span> text, <span class="operator">!</span>text.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> attrString <span class="operator">=</span> <span class="type">NSMutableAttributedString</span>(string: text)</span><br><span class="line">    </span><br><span class="line">    attrString.addAttributes(</span><br><span class="line">        attributes,</span><br><span class="line">        range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, attrString.length))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> frameSetter <span class="operator">=</span> <span class="type">CTFramesetterCreateWithAttributedString</span>(attrString)</span><br><span class="line">    <span class="keyword">let</span> textRect <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: fitWidth, height: <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">let</span> textRectPath <span class="operator">=</span> <span class="type">UIBezierPath</span>(rect: textRect).cgPath</span><br><span class="line">    <span class="keyword">let</span> frame <span class="operator">=</span> <span class="type">CTFramesetterCreateFrame</span>(</span><br><span class="line">        frameSetter, <span class="type">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        textRectPath,</span><br><span class="line">        <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">let</span> lines <span class="operator">=</span> <span class="type">CTFrameGetLines</span>(frame) <span class="keyword">as!</span> [<span class="type">CTLine</span>]</span><br><span class="line">    <span class="keyword">var</span> linesArray <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines &#123;</span><br><span class="line">        <span class="keyword">let</span> lineRange <span class="operator">=</span> <span class="type">CTLineGetStringRange</span>(line)</span><br><span class="line">        <span class="keyword">let</span> range <span class="operator">=</span> <span class="type">NSMakeRange</span>(</span><br><span class="line">            lineRange.location,</span><br><span class="line">            lineRange.length)</span><br><span class="line">        <span class="keyword">let</span> lineString <span class="operator">=</span> <span class="type">NSString</span>(string: text).substring(with: range)</span><br><span class="line">        linesArray.append(lineString)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linesArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对文本的最后一行进行拼接"><a href="#2-对文本的最后一行进行拼接" class="headerlink" title="2. 对文本的最后一行进行拼接"></a>2. 对文本的最后一行进行拼接</h3><p>首先把省略提示文字拼接到末尾，计算长度，如果长度超过可显示的宽度，则截取最后一个字。如此循环，直到文字宽度小于指定宽度。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">trimmingTail</span>(<span class="params">for</span> <span class="params">string</span>: <span class="type">String</span>, <span class="params">appendString</span>: <span class="type">String</span>, <span class="params">fitWidth</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> trimmedString <span class="operator">=</span> string</span><br><span class="line">    <span class="keyword">var</span> stringWidth <span class="operator">=</span> calculateLength(trimmedString <span class="operator">+</span> appendString)</span><br><span class="line">    <span class="keyword">while</span> stringWidth <span class="operator">&gt;</span> fitWidth &#123;</span><br><span class="line">        trimmedString.removeLast()</span><br><span class="line">        stringWidth <span class="operator">=</span> calculateLength(trimmedString <span class="operator">+</span> appendString)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trimmedString</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">calculateLength</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>) -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> targetString <span class="operator">=</span> <span class="type">NSString</span>(string: string)</span><br><span class="line">    <span class="keyword">let</span> size <span class="operator">=</span> targetString.boundingRect(</span><br><span class="line">        with: <span class="type">CGSize</span>(width: <span class="number">1000</span>, height: <span class="number">250</span>),</span><br><span class="line">        options: [.usesLineFragmentOrigin],</span><br><span class="line">        attributes: attributes,</span><br><span class="line">        context: <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> size.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-根据规则设置"><a href="#3-根据规则设置" class="headerlink" title="3. 根据规则设置"></a>3. 根据规则设置</h3><p>最后则是判断是否应该添加更多的选项。如果没有超过指定行数，则不进行任何处理，如果超过了指定行数，则为最后一行文本添加“更多”文字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">setReadMore</span>(<span class="keyword">_</span> <span class="params">appendString</span>: <span class="type">String</span>, <span class="params">fitWidth</span>: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lineTexts <span class="operator">=</span> getLines(fitWidth: fitWidth)</span><br><span class="line">    <span class="keyword">if</span> lineTexts.count <span class="operator">&lt;=</span> numberOfLines &#123;</span><br><span class="line">        isUserInteractionEnabled <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        attributedText <span class="operator">=</span> <span class="type">NSAttributedString</span>(string: text <span class="operator">??</span> <span class="string">&quot;&quot;</span>, attributes: attributes)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> contentText <span class="operator">=</span> <span class="type">String</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfLines &#123;</span><br><span class="line">        <span class="keyword">var</span> lineText <span class="operator">=</span> lineTexts[i]</span><br><span class="line">        <span class="keyword">if</span> i <span class="operator">==</span> numberOfLines <span class="operator">-</span> <span class="number">1</span> &#123;</span><br><span class="line">            lineText <span class="operator">=</span> trimmingTail(for: lineText, appendString: appendString, fitWidth:  fitWidth)</span><br><span class="line">                .trimmingCharacters(in: .newlines)</span><br><span class="line">        &#125;</span><br><span class="line">        contentText.append(lineText)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> contentText <span class="operator">+</span> appendString</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> resultAttrString <span class="operator">=</span> <span class="type">NSMutableAttributedString</span>(string: result)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> range <span class="operator">=</span> <span class="type">NSMakeRange</span>(<span class="number">0</span>, resultAttrString.length)</span><br><span class="line">    resultAttrString.addAttributes(</span><br><span class="line">        attributes,</span><br><span class="line">        range: range)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> linkRange <span class="operator">=</span> <span class="type">NSMakeRange</span>(resultAttrString.length <span class="operator">-</span> appendString.count, appendString.count)</span><br><span class="line">    resultAttrString.addAttributes(</span><br><span class="line">        [</span><br><span class="line">            .foregroundColor: <span class="type">UIColor</span>.blue,</span><br><span class="line">        ],</span><br><span class="line">        range: linkRange)</span><br><span class="line">    attributedText <span class="operator">=</span> resultAttrString</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>这样基本的功能就已经实现了，只需要在填充文本之后调用 <code>setReadMore</code> 就可以实现显示更多的样式了。使用方式如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label.numberOfLines <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">label.text <span class="operator">=</span> <span class="string">&quot;Some text content...&quot;</span></span><br><span class="line">label.setReadMore(<span class="string">&quot;显示全文&quot;</span>, fitWidth: <span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>如果你发现本文有任何疏漏错误，还请不吝指出，多谢。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UILabel </tag>
            
            <tag> 文本处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BackgroundTasks实践</title>
      <link href="/2021/07/14/BackgroundTasks%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/07/14/BackgroundTasks%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>BackgroundTasks  框架包含两种后台任务，一种是用于后台更新应用程序内容的 <code>BGAppRefreshTask</code>，一种是用于执行繁重任务比如模型训练、数据同步等的 <code>BGProcessingTask</code>。 ^a71227</p><p>由于两种后台任务的开启方式大同小异，所以接下来的内容主要以 <code>BGAppRefreshTask</code> 来进行。</p><h3 id="1-开启后台任务的前期准备"><a href="#1-开启后台任务的前期准备" class="headerlink" title="1. 开启后台任务的前期准备"></a>1. 开启后台任务的前期准备</h3><p>为了让应用程序能够支持后台任务执行，首先要让应用程序支持后台任务。选中应用程序对应的 target，在 Capability 一栏中搜索 <code>Background Modes</code> 并添加（如果已添加则跳过），将 <code>Background fetch</code> 勾选上（如果是 <code>BGProcessingTask</code> 则需要勾选 <code>Background processing</code>）。之后打开 <code>Info.plist</code>，添加一个新的属性 <code>Permitted background task scheduler identifiers</code>，这是一个数组类型，在数组种添加一个字符串类型新项目，这即是后台任务的 identifier，每个后台任务都需要有一个 identifier。identifier 的名字建议还是以 com.app.taskName 的格式来命名，此处设置为 com.demo.refresh。</p><h3 id="2-注册后台任务"><a href="#2-注册后台任务" class="headerlink" title="2. 注册后台任务"></a>2. 注册后台任务</h3><p>在应用程序启动时，我们需要使用 <code>BGTaskScheduler</code> 的单例来注册后台任务。<code>BGTaskScheduler</code> 是一个用于调度在后台启动应用程序的任务请求的类。调用 <code>register(forTaskWithIdentifier:using:launchHandler:)</code> 注册后台任务。注册方法一共需要传递 3 个参数。<br>第一个是后台任务的 identifier，也即之前在 Info.plist 添加的 identifier。<br>第二个参数是一个线程队列，此队列必须是串行的，以保证一致的顺序，可以传 nil，系统会自动运行在一个默认的后台队列上。<br>第三个参数 <code>launchHandler</code> 会在后台任务被触发时被调用，闭包包含一个 <code>BGTask</code> 参数，在闭包中要设置 task 的 <code>expirationHandler</code> 以及要在所有任务结束后调用 <code>setTaskCompletedWithSuccess:</code>。</p><p>需要注意的是，注册必须在应用程序启动完成之前执行，如果是在启动完成之后或是注册多个相同 identifier 的任务会报错，且注册只能在宿主应用而不是扩展中注册。</p><p>上述完整代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="type">UIApplication</span>.<span class="params">LaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="comment">// Override point for customization after application launch.</span></span><br><span class="line"><span class="type">BGTaskScheduler</span>.shared.register(forTaskWithIdentifier: <span class="string">&quot;com.demo.refresh&quot;</span>, using: <span class="literal">nil</span>) &#123; task <span class="keyword">in</span></span><br><span class="line"><span class="comment">// 因为这是一个刷新的Task，所以要强转</span></span><br><span class="line"><span class="keyword">self</span>.handleAppRefresh(task <span class="keyword">as!</span> <span class="type">BGAppRefreshTask</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">handleAppRefresh</span>(<span class="keyword">_</span> <span class="params">task</span>: <span class="type">BGAppRefreshTask</span>) &#123;</span><br><span class="line"><span class="comment">// 再次启动</span></span><br><span class="line"><span class="comment">// scheduleAppRefresh()    </span></span><br><span class="line"><span class="comment">/* 执行任务 operation */</span></span><br><span class="line">operation.finished <span class="operator">=</span> &#123;</span><br><span class="line">task.setTaskCompleted(success: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    task.expirationHandler <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="comment">// cancel refresh operation</span></span><br><span class="line">        operation.cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-启动后台任务"><a href="#3-启动后台任务" class="headerlink" title="3. 启动后台任务"></a>3. 启动后台任务</h3><p>做好了前面的准备，我们终于可以启动我们的后台任务了。那么什么时候启动后台任务呢？最佳的时机应该是应用进入到后台的时候。所以在<code>applicationDidEnterBackground</code> 或者 <code>sceneDidEnterBackground</code> 中调用启动后台任务。</p><p>我们使用 <code>BGAppRefreshTaskRequest</code> 来创建一个后台任务请求，然后将请求提交到 <code>BGTaskScheduler</code>。请求有一个 <code>earliestBeginDate</code> 用来表示后台任务最早可以在什么时候开始，可以设置为一周以内的时间，此处我们设置了 30 分钟。</p><p><code>BGProcessingTaskRequest</code> 还有两外两个参数可以设置：</p><ul><li>requiresNetworkConnectivity，是否需要网络，默认为 false。如果设置为 true，则后台任务只会在联网状态下才会启动；</li><li>requiresExternalPower，是否需要外部电源，也就是充电状态，默认为 false。如果设置为 true 则只会在充电状态下才会启动后台任务。需要注意的是，即使设置为 false，后台任务也不一定会启动，这取决于设备和系统的状态。</li></ul><p>启动和提交后台任务的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">scheduleAppRefresh</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> <span class="type">BGAppRefreshTaskRequest</span>(identifier: <span class="string">&quot;com.demo.refresh&quot;</span>)</span><br><span class="line">    request.earliestBeginDate <span class="operator">=</span> <span class="type">Date</span>(timeIntervalSinceNow: <span class="number">30</span> <span class="operator">*</span> <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="type">BGTaskScheduler</span>.shared.submit(request)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Could not schedule app refresh: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为后台任务只会响应一次，所以要在接收到后台任务响应的时候再次启动才能让后台任务一直存在，也就是 <code>handleAppRefresh</code> 方法中注释的第一行。</p></blockquote><h3 id="4-模拟后台任务的启动和失效"><a href="#4-模拟后台任务的启动和失效" class="headerlink" title="4. 模拟后台任务的启动和失效"></a>4. 模拟后台任务的启动和失效</h3><p>由于后台任务是由系统来控制执行时机，所以开发者无法确定相关代码什么时候会执行，这样就不利于调试，不过我们可以模拟相关事件的产生。</p><p>模拟后台任务启动，我们先将应用程序运行起来，进入后台，再进入前台，此时按下暂停，在调试窗口输入如下代码后回车：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&quot;com.demo.refresh&quot;]</span><br></pre></td></tr></table></figure><p>如果没有意外的话，控制台会输出 <code>Simulating launch for task with identifier com.demo.refresh</code>。这表示后台程序已经执行了。</p><p>模拟后台任务过期的代码如下，和模拟启动基本一致，就不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&quot;com.demo.refresh&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>模拟后台任务的启动和过期时不能使用模拟器，必须使用真机，且要将手机设置中的 <code>后台App 刷新</code> 开关打开，不然模拟会报错 <code>BGTaskSchedulerErrorCodeUnavailable</code>。</p></blockquote><blockquote><p><strong>参考资料</strong><br><a href="https://developer.apple.com/videos/play/wwdc2019/707">Advances in App Background Execution</a><br><a href="https://developer.apple.com/documentation/backgroundtasks/bgtaskscheduler/error/code">BGTaskScheduler.Error.Code</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 中如何实现后台下载</title>
      <link href="/2021/05/12/iOS-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2021/05/12/iOS-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>新需求有一个后台下载的功能，由于之前没有涉及过相关内容，于是马上开始搜索 Moya 怎么实现后台下载，一搜才发现，最新的 Moya 已经不支持后台下载了，那就只有用原生的 URLSession 来做了。</p><p>先来看一下整个后台下载的流程：</p><ul><li>打开应用程序，启动后台下载任务；</li><li>进入后台，下载在后台继续；</li><li>下载完成后，会调用 <code>UIApplicationDelegate</code> 的 <code>application(_ application:handleEventsForBackgroundURLSession:completionHandler:)</code> 方法，此处意思就是如果后台下载完成后，提供一个闭包，可以调用闭包方法告诉系统我们的应用可以被suspend了；</li><li>接着会调用 <code>URLSessionDelegate</code> 的 <code>urlSessionDidFinishEvents(forBackgroundURLSession:</code> 方法，在这里我们获取上一步中的闭包进行调用。</li></ul><p>好了，接下来看详细的代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BackgroundDownloadManager</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="comment">/// **下载进度回调**</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> progressHandler: ((<span class="type">Double</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// **下载成功之后的回调**</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> completionHandler: ((<span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> session: <span class="type">URLSession</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> config <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">&quot;com.demo.download&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>(configuration: config, delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span> session</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">download</span>(<span class="params">urlString</span>: <span class="type">String</span>, <span class="params">progress</span>: ((<span class="type">Double</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>, <span class="params">completion</span>: ((<span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.progressHandler <span class="operator">=</span> progress</span><br><span class="line">        <span class="keyword">self</span>.completionHandler <span class="operator">=</span> completion</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: urlString)<span class="operator">!</span></span><br><span class="line">        <span class="keyword">let</span> urlRequest <span class="operator">=</span> <span class="type">URLRequest</span>(url: url)</span><br><span class="line">        <span class="keyword">let</span> task <span class="operator">=</span> session.downloadTask(with: urlRequest)</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">BackgroundDownloadManager</span>: <span class="title class_">URLSessionDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">urlSessionDidFinishEvents</span>(<span class="params">forBackgroundURLSession</span> <span class="params">session</span>: <span class="type">URLSession</span>) &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> appDelegate <span class="operator">=</span> <span class="type">UIApplication</span>.shared.delegate <span class="keyword">as?</span> <span class="type">AppDelegate</span>,</span><br><span class="line">                <span class="keyword">let</span> completionHandler <span class="operator">=</span> appDelegate.backgroundCompletionHandler &#123;</span><br><span class="line">                completionHandler()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">BackgroundDownloadManager</span>: <span class="title class_">URLSessionDownloadDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">downloadTask</span>: <span class="type">URLSessionDownloadTask</span>, <span class="params">didWriteData</span> <span class="params">bytesWritten</span>: <span class="type">Int64</span>, <span class="params">totalBytesWritten</span>: <span class="type">Int64</span>, <span class="params">totalBytesExpectedToWrite</span>: <span class="type">Int64</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> progress <span class="operator">=</span> <span class="type">Double</span>(totalBytesWritten) <span class="operator">/</span> <span class="type">Double</span>(totalBytesExpectedToWrite)</span><br><span class="line">        progressHandler<span class="operator">?</span>(progress)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">downloadTask</span>: <span class="type">URLSessionDownloadTask</span>, <span class="params">didFinishDownloadingTo</span> <span class="params">location</span>: <span class="type">URL</span>) &#123;</span><br><span class="line">        progressHandler<span class="operator">?</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">let</span> fileName <span class="operator">=</span> dateToString(date: <span class="type">Date</span>(), format: <span class="string">&quot;yyyyMMddHHmmss&quot;</span>) <span class="operator">+</span> <span class="string">&quot;.tmp&quot;</span></span><br><span class="line">        <span class="keyword">let</span> newLocation <span class="operator">=</span> <span class="type">NSHomeDirectory</span>() <span class="operator">+</span> <span class="string">&quot;/Documents/&quot;</span> <span class="operator">+</span> fileName</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> <span class="type">FileManager</span>.default.moveItem(atPath: location.path, toPath: newLocation)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Move item failed: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        completionHandler<span class="operator">?</span>(newLocation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">dateToString</span>(<span class="params">date</span>: <span class="type">Date</span>, <span class="params">format</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dateFormatter <span class="operator">=</span> <span class="type">DateFormatter</span>()</span><br><span class="line">        dateFormatter.dateFormat <span class="operator">=</span> format</span><br><span class="line">        <span class="keyword">return</span> dateFormatter.string(from: date)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>AppDelegate</code> 实现下面的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backgroundCompletionHandler: (() -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">handleEventsForBackgroundURLSession</span> <span class="params">identifier</span>: <span class="type">String</span>, <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        backgroundCompletionHandler <span class="operator">=</span> completionHandler</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后开启下载：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> downloadManager <span class="operator">=</span> <span class="type">BackgroundDownloadManager</span>()</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">startBackgroundDownload</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> urlString <span class="operator">=</span> <span class="string">&quot;your file url&quot;</span></span><br><span class="line">    downloadManager.download(urlString: urlString) &#123; progress <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;下载进度: <span class="subst">\(progress)</span>&quot;</span>)</span><br><span class="line">    &#125; completion: &#123; location <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;文件已保存到: <span class="subst">\(location)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，一个完整的后台下载就结束了。</p><blockquote><p><strong>参考资料</strong><br><a href="https://developer.apple.com/documentation/foundation/url_loading_system/downloading_files_in_the_background">Downloading Files in the Background</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 如何进行单元测试</title>
      <link href="/2021/04/12/Golang-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/04/12/Golang-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>在 golang 中，如果有一个 practice.go 的文件，那么在后面加上 _test（practice_test.go） 就是对应的单元测试文件。当构建程序时，名为 xxx_test.go 的文件会被编译器忽略。一般来说，单元测试的文件和被测试的文件放在同一个目录下，单元测试文件也是 package 的一部分。</p><h3 id="第一个单元测试"><a href="#第一个单元测试" class="headerlink" title="第一个单元测试"></a>第一个单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> greeting</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hello, %s!&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> greeting</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSayHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    expected := <span class="string">&quot;Hello, Andy!&quot;</span></span><br><span class="line">    actual := sayHello(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> expected != actual &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Actual %s does not match expected %s&quot;</span>, actual, expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>单元测试的方法签名分为两部分，第一部分是固定的 Test，第二部分则是被测试的方法名，且必须是大写字母开头。</p><p>单元测试没有标记成功的方法，当测试方法没有调用任何失败方法时，就意味着测试成功。要标记失败，有如下几种方式：</p><ul><li><code>Error</code>，记录日志，标记单元测试方法失败，测试将继续</li><li><code>Errorf</code>，同上，日志按照指定格式记录</li><li><code>Fail</code>，标记单元测试方法失败，测试将继续</li><li><code>FailNow</code>，标记测试失败，将不会继续执行</li><li><code>Fatal</code>，同<code>FailNow</code> + 记录日志</li><li><code>Fatalf</code>，同<code>FailNow</code> + 指定格式记录日志</li></ul><p>如果需要使用额外的文件，如配置文件等，将其放在当前目录的 <code>testdata</code> 文件夹下。</p><p>以上的单元测试使用的是标准库的方法，也可以引入开源库来做断言处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go getgithub.com/stretchr/testify</span><br></pre></td></tr></table></figure><p>上面的测试代码就可以改写成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> greeting</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSayHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    assert.Equal(t, <span class="string">&quot;Hello, Andy!&quot;</span>, sayHello(<span class="string">&quot;Bob&quot;</span>), <span class="string">&quot;Not equal&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行单元测试"><a href="#执行单元测试" class="headerlink" title="执行单元测试"></a>执行单元测试</h3><p>只需 cd 到对应文件的目录下，执行<code>go test</code> 即可执行单元测试，这个命令会执行当前目录下 package 中的所有测试用例。如果想要执行整个项目中的所有测试用例，可以使用 <code>go test ./...</code>。</p><p>在 <code>go test</code> 执行的过程中，go 也会在 package 中自动执行 <code>go vet</code>。<code>go vet</code>命令是 Go 工具链的一部分。它可以对源代码进行语法验证，以检测潜在的错误。这个命令有一个完整的检查列表，但是在运行 go 测试时，只启动一个小的检测列表子集。</p><ul><li>atomic：检测出 sync&#x2F;atomic 包的错误使用。</li><li>bool：验证布尔条件的使用情况。</li><li>buildtags：验证在输入的命令中<code>go test</code>是否正确拼装了 build 标签。</li><li>nilfunc：检查是否将函数与nil进行比较。</li></ul><p>在启动单元测试之前自动运行<code>go vet</code>命令可以使你在对程序造成影响之前就发现这些错误。</p><h3 id="多个测试用例"><a href="#多个测试用例" class="headerlink" title="多个测试用例"></a>多个测试用例</h3><p>如果一个方法有多个测试用例需要去测试，那么该如何去写呢？最容易想到的肯定是直接复制然后修改。其实可以把测试用例参数化，具体来看如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSayHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">args args</span><br><span class="line">want <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">&quot;test Bob&quot;</span>,</span><br><span class="line">args: args&#123;<span class="string">&quot;Bob&quot;</span>&#125;,</span><br><span class="line">want: <span class="string">&quot;Hello, Bob!&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">&quot;test Andy&quot;</span>,</span><br><span class="line">args: args&#123;<span class="string">&quot;Andy&quot;</span>&#125;,</span><br><span class="line">want: <span class="string">&quot;Hello, Andy!&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">&quot;Mike&quot;</span>,</span><br><span class="line">args: args&#123;<span class="string">&quot;Mike&quot;</span>&#125;,</span><br><span class="line">want: <span class="string">&quot;Hello, Mike!&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> got := sayHello(tt.args.name); got != tt.want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;sayHello() = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，创建一个名为 <code>args</code> 的 <code>struct</code>。每一个字段都代表待测试方法中的参数。<br>然后再创建一个 <code>tests</code> 的 <code>struct</code>，这里有三个字段：</p><ul><li>name，即该测试用例的名字，一般取个比较易读易理解的名字。</li><li>args，传递给被测试方法的参数。</li><li>want，期望执行方法的返回值。</li></ul><p>接下来的循环中，则是遍历执行测试用例了。这样添加或删除测试用例就方便多了。</p><h3 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h3><p>如果项目中测试用例太多或者耗时太长，就需要引入并行测试了。</p><p>新添加三个测试方法，每个方法不做其它事情，只是单纯地 sleep 500毫秒。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGreeting1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGreeting2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGreeting3</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试，终端输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PASS</span><br><span class="line">ok      greeting   2.248s</span><br></pre></td></tr></table></figure><p>可以看到，耗时是相当长的。此时只需要在每个测试方法里面加上<code>t.Parallel()</code>，再次运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PASS</span><br><span class="line">ok      greeting   0.937s</span><br></pre></td></tr></table></figure><p>测试时间成功变少了，而仅仅只是添加了一句代码而已。</p><h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p><code>go test</code> 添加 <code>-cover</code> 参数可以查看测试覆盖率，也可以通过 <code>go test -coverprofile profile</code> 生成报告。报告内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mode: set</span><br><span class="line">golib/greeting.go:5.35,7.2 1 1</span><br><span class="line">golib/greeting.go:9.19,9.20 0 0</span><br><span class="line">golib/greeting.go:10.19,10.20 0 0</span><br><span class="line">golib/greeting.go:11.19,11.20 0 0</span><br></pre></td></tr></table></figure><p>这个文件并不易读。第一行先忽略，从第二行开始看。首先是文件路径，5.35代表了测试块的起始行列，7.2代表了测试块的结束行列。接下来的两个数字分别表示总的语句数量和测试覆盖到的语句数量。</p><p>由于此文件并不清晰易读，可以使用 <code>go tool cover -html=profile</code> 生成一个 html 文件并在浏览器中打开。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 中的并发</title>
      <link href="/2021/03/15/Golang%20%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91/"/>
      <url>/2021/03/15/Golang%20%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>关于什么是并发，竞争和死锁等在这里就不讨论了。Golang 中实现并发系统的主要工具就是 goroutine。</p><h3 id="1-Goroutine"><a href="#1-Goroutine" class="headerlink" title="1 Goroutine"></a>1 Goroutine</h3><p>Goroutine 是一个独立于程序其余部分执行的函数，它的基本元素是一个函数。每个函数都可以成为 goroutine，只需要在函数调用之前添加 <code>go</code> 关键字。每个程序都存在一个 goroutine，那就是 main goroutine。</p><p>来看一个例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Launch goroutine&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> printNumber()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Minute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumber</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">i++</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 main 函数睡眠了1分钟，但是 printNumber 函数还是会照常执行。</p><h3 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2 Channel"></a>2 Channel</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>Channel  是一种类型化的通信管道。Goroutine 可以通过通道相互通信。通道可以看作是两个 goroutine 之间的数据管道。此管道只能支持特定类型。</p><h4 id="2-2-Channel-类型"><a href="#2-2-Channel-类型" class="headerlink" title="2.2 Channel 类型"></a>2.2 Channel 类型</h4><p>Channel 分为 3 种类型，分别是：</p><ul><li>只能发送，语法为：chan &lt;- T（T 为 channel 所支持的类型，下同）</li><li>只能接收，语法为：&lt;- chan T</li><li>双向，语法为：chan T<br><img src="https://www.practical-go-lessons.com/img/channel_direction.812e0b41.png" alt="channel的三种类型"></li></ul><h4 id="2-3-Channel-的初始化"><a href="#2-3-Channel-的初始化" class="headerlink" title="2.3 Channel 的初始化"></a>2.3 Channel 的初始化</h4><p>Channel 同样使用 Go 内建的 make 函数进行初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>第一种方式创建了一个 int 类型的不带缓冲的 channel，它等价于 <code>make(chan int, 0)</code>，第二种方式创建了一个 int 类型缓冲大小为 3 的 channel。</p><p>可以通过 <code>len</code> 函数获取 channel 中的元素个数，<code>cap</code> 函数则可以获取到 channel 的缓冲区大小。</p><h4 id="2-4-使用-channel-发送数据"><a href="#2-4-使用-channel-发送数据" class="headerlink" title="2.4 使用 channel 发送数据"></a>2.4 使用 channel 发送数据</h4><p>使用 <code>&lt;-</code> 来表示将数据发送到这个 channel，这个符号代表数据从右边流动到左边。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">42</span></span><br></pre></td></tr></table></figure><p>上面的代码初始化了一个缓存为3的 channel，然后将 42 发送到这个 channel。</p><p>发送数据需要注意一些特性：</p><ol><li>channel 和表达式在通信之前执行；</li><li>仅在 channel 打开的时候可以发送，如果是 close 的时候发送则会引起程序 panic；</li><li>如果 channel 为 nil，向其发送数据会永久阻塞程序执行。</li></ol><h4 id="2-5-关闭-channel"><a href="#2-5-关闭-channel" class="headerlink" title="2.5 关闭 channel"></a>2.5 关闭 channel</h4><p>使用内建的 close 函数来关闭 channel，关闭 channel 意味着不再有数据发送从这个 channel 发送。</p><ul><li>无法关闭一个仅接收的 channel；</li><li>无法向一个关闭的 channel 发送数据；</li><li>无法关闭一个已经关闭的 channel；</li><li>可以从一个已经关闭的 channel 接收数据。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">42</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-6-接收-channel-的数据"><a href="#2-6-接收-channel-的数据" class="headerlink" title="2.6 接收 channel 的数据"></a>2.6 接收 channel 的数据</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">42</span></span><br><span class="line">ch &lt;- <span class="number">41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">val := &lt;- ch</span><br><span class="line">fmt.Println(val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">val, ok := &lt;- ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Channel is empty or closed.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方式 1 中，使用变量 val 来接收 channel 中的数据，输出为 42。<br>方式 2 中，使用了两个变量来接收 channel 的数据，ok 用来判断 channel 是否为空或者是否已关闭。ok 为 true 则 val 能正常接收到数据，ok 为 false 则表示 channel 为空或已关闭。本例中，输出为 42。</p><h4 id="2-7-无缓冲-Channel"><a href="#2-7-无缓冲-Channel" class="headerlink" title="2.7 无缓冲 Channel"></a>2.7 无缓冲 Channel</h4><p>当向无缓冲的 channel 发送数据时，goroutine 会被阻塞，直到数据被另一个 goroutine 接收。这是因为 channel 没有缓冲来存储发送的数据，因此当前 goroutine 阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> printNumber(ch)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Launch goroutine&quot;</span>)</span><br><span class="line">ch &lt;- <span class="number">42</span></span><br><span class="line">log.Println(<span class="string">&quot;Received&quot;</span>)</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Minute * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumber</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">val := &lt;-ch</span><br><span class="line">log.Println(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2022/09/09 08:51:23 Launch goroutine</span><br><span class="line">2022/09/09 08:51:26 Received</span><br><span class="line">2022/09/09 08:51:26 42</span><br></pre></td></tr></table></figure><p>可以看到，因为 channel 没有缓冲，并且接收数据的 goroutine 睡眠了 3 秒，因此发送数据的 channel 阻塞了 3 秒才继续执行。 </p><h4 id="2-8-缓冲-channel"><a href="#2-8-缓冲-channel" class="headerlink" title="2.8 缓冲 channel"></a>2.8 缓冲 channel</h4><p>将前一节的 <code>ch := make(chan int)</code> 修改为 <code>ch := make(chan int, 1)</code> ，执行后输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2022/09/09 08:59:50 Launch goroutine </span><br><span class="line">2022/09/09 08:59:50 Received</span><br><span class="line">2022/09/09 08:59:53 42</span><br></pre></td></tr></table></figure><p>可以看到，带有缓冲的 channel 因为有缓冲区，因此在缓冲区还未满的时候发送数据不会被阻塞。</p><h4 id="2-9-Channel-用例"><a href="#2-9-Channel-用例" class="headerlink" title="2.9 Channel 用例"></a>2.9 Channel 用例</h4><h5 id="2-9-1-线程同步"><a href="#2-9-1-线程同步" class="headerlink" title="2.9.1 线程同步"></a>2.9.1 线程同步</h5><p>无缓冲 channel 可用来实现两个 goroutine 之间的同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">syncCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">process2()</span><br><span class="line">syncCh &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line">process1()</span><br><span class="line">&lt;- syncCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process2</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process1</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收操作 <code>&lt;-syncCh</code>  一直阻塞，直到另一个 goroutine 完成。为了表示它已经完成，第二个 goroutine 将在通道中发送值 <code>true</code>。</p><h4 id="2-10-死锁"><a href="#2-10-死锁" class="headerlink" title="2.10 死锁"></a>2.10 死锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span> </span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> receive(ch)</span><br><span class="line">log.Println(<span class="string">&quot;waiting for reception...&quot;</span>) </span><br><span class="line">ch &lt;- <span class="number">45</span></span><br><span class="line">ch &lt;- <span class="number">58</span> </span><br><span class="line">ch &lt;- <span class="number">100</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">smth := &lt;-c </span><br><span class="line">log.Println(<span class="string">&quot;has received something&quot;</span>, smth) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个缓冲大小为 1 的 channel，然后将45，58，100 三个数字传给 channel，receive 函数中会接收45，58可以存储在缓冲中，而 100 则因为没有多余的空间存储，所以会阻塞main goroutine 而无限地等待下去。</p><h4 id="2-11-Select-语句"><a href="#2-11-Select-语句" class="headerlink" title="2.11 Select 语句"></a>2.11 Select 语句</h4><ul><li>Select 语句类似于其它语言中的 <code>switch case</code> ，只不过是用于通信操作。</li><li>Select 语句中有多个 <code>case</code> 和可选的 <code>default</code> 实现。</li><li>第一个非阻塞选项将会被选中。</li><li>如果有两个或更多的未阻塞 case，则采用统一伪随机选择一个。</li><li>如果所有 <code>case</code> 都被阻塞，则会执行 <code>default</code> 。<br><img src="https://www.practical-go-lessons.com/img/select_statement_syntax.78dbdc87.png" alt="select 执行逻辑"></li></ul><h4 id="2-12-Wait-groups"><a href="#2-12-Wait-groups" class="headerlink" title="2.12 Wait groups"></a>2.12 Wait groups</h4><p>Wait group 是标准库提供的一种同步工具，它可以用在等待一组 goroutine 完成它们的任务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> waitGroup sync.WaitGroup</span><br><span class="line"><span class="comment">// wait counter +10</span></span><br><span class="line">waitGroup.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> concurrentTask(i, &amp;waitGroup)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 阻塞当前 goroutine，直到wait counter为0</span></span><br><span class="line">waitGroup.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concurrentTask</span><span class="params">(taskId <span class="type">int</span>, waitGroup *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line"><span class="comment">// 将wait counter -1</span></span><br><span class="line">waitGroup.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-13-Mutexes"><a href="#2-13-Mutexes" class="headerlink" title="2.13 Mutexes"></a>2.13 Mutexes</h4><p>Mutex 是一种同步工具，Mutex 是 Mutual Exclusion 的缩写。当两件事情不能同时发生的时候我们称之为互斥。可以使用互斥来避免数据竞争。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> group sync.WaitGroup</span><br><span class="line">group.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> increment(&amp;group)</span><br><span class="line">&#125;</span><br><span class="line">group.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(group *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">number++</span><br><span class="line">log.Println(number)</span><br><span class="line">&#125;</span><br><span class="line">group.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码开了10个 goroutine，每个goroutine对变量number执行100次+1。但是执行结果很可能并不是我们所期待的1000。这是因为产生了data race，有 goroutine 同时修改了 number，导致最终数据不正确。</p><p>只要将代码稍加修改，也就是加了一把互斥锁就能正确执行了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> mutext sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> group sync.WaitGroup</span><br><span class="line">group.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> increment(&amp;group)</span><br><span class="line">&#125;</span><br><span class="line">group.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(group *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">mutex.Lock()</span><br><span class="line">number++</span><br><span class="line">mutex.Unlock()mutex</span><br><span class="line">log.Println(number)</span><br><span class="line">&#125;</span><br><span class="line">group.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 包的初始化过程</title>
      <link href="/2021/02/14/Golang-%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/02/14/Golang-%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>先上结论：</p><ul><li>导入的 package 先初始化<ul><li>变量初始化</li><li><code>init</code> 方法开始运行</li></ul></li><li>本身 package 初始化<ul><li>本身变量初始化</li><li>本身 <code>init</code> 方法开始运行</li></ul></li></ul><p>下面，通过一些例子来验证上述结论。<br>新建一个recipe的项目，<code>main.go</code>文件导入引入包<code>menu</code>，包<code>menu</code>引入包<code>colddish</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;recipe/menu&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;package main inited.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">menu.ShowMenus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// menu.go</span></span><br><span class="line"><span class="keyword">package</span> menu</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;recipe/colddish&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;package menu inited.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;variable m initialized.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;menu&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowMenus</span><span class="params">()</span></span> &#123;</span><br><span class="line">colddish.ShowColddish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// colddish.go</span></span><br><span class="line"><span class="keyword">package</span> colddish</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;package colddish inited.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;variable c initialized.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;colddish&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;variable b initialized.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;colddish&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;variable a initialized.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;colddish&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowColddish</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Colddish&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，可以看到打印的顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable c initialized. </span><br><span class="line">variable b initialized. </span><br><span class="line">variable a initialized. </span><br><span class="line">package colddish inited. </span><br><span class="line">variable m initialized. </span><br><span class="line">package menu inited. </span><br><span class="line">package main inited. </span><br></pre></td></tr></table></figure><p>如果把<code>colddish.go</code>中的变量更改为如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;variable c initialized.&quot;</span>, b)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;c&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;variable b initialized.&quot;</span>, a)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;variable a initialized.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>此时变量之间存在着依赖，来看看对应的初始化顺序是否会有改变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable a initialized. </span><br><span class="line">variable b initialized. a </span><br><span class="line">variable c initialized. b </span><br><span class="line">package colddish inited. </span><br><span class="line">variable m initialized. </span><br><span class="line">package menu inited. </span><br><span class="line">package main inited.</span><br></pre></td></tr></table></figure><p>可以看到，此时的变量初始化顺序发生了变化，其原因是变量之间存在着依赖。</p><p>总结一下就是，在运行的过程中，编译器会按声明顺序遍历所有待初始化的变量，如果变量A不依赖未被初始化的变量，变量A则会正常初始化，反之则会跳过。重复这个过程直到所有的变量都被初始化，那么整个初始化流程就走完了。对包的初始化也是如此，按照依赖层级一层层的回溯。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】在Swift中实现MVVM</title>
      <link href="/2020/06/12/%E5%9C%A8Swift%E4%B8%AD%E5%AE%9E%E7%8E%B0MVVM/"/>
      <url>/2020/06/12/%E5%9C%A8Swift%E4%B8%AD%E5%AE%9E%E7%8E%B0MVVM/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://www.iosapptemplates.com/blog/ios-development/mvvm-swift">How to Implement the MVVM Design Pattern in Swift</a></p><p>如你所知，在 Swift 中有许多适用的设计模式比如 MVC，MVP 和 MVVM。我们根据项目的需求来选择最合适的。在iosapptemplates.com，我们使用了多种模式来构建我们的函数式App。在这片文章中，我们将指出使用MVVM所带来的一些优势并且用一些Swift代码片段进行清晰地解释。</p><p>MVVM代表Model - View（View 在此处表示ViewController）- ViewModel（VM）。那这是什么意思呢？这意味着我们将要引入一个新的叫做View Model的组件来帮助处理繁重的工作。</p><p>先前，所有事情包括网络，获取响应，处理来自UI的信号等等都是在View Controller中进行。这使得View Controller臃肿过载。所以在MVVM中，我们将把上述工作和代理职责划分到view model中去。</p><h3 id="组件概览和具体职责"><a href="#组件概览和具体职责" class="headerlink" title="组件概览和具体职责"></a>组件概览和具体职责</h3><p>所以总的来说，我们有：</p><ul><li>View Controller：只展示和UI相关的事情——显示或者获取信息，View层的一部分</li><li>View Model：接收来自VC的信息，处理所有接收到的信息并返回给VC</li><li>Model：这只是model，同MVC中的model完全一样。VM使用它，并在VM发送新更新时进行更新</li></ul><p><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/03/Screen-Shot-2019-03-17-at-8.25.44-PM.png"></p><p>在一个实际的项目中，应该记住两个主要的点：</p><ol><li>像这样分离工作所带来的便利。</li><li>负责任何特定部分的每个组件都将彼此完全独立。</li></ol><h3 id="MVVM-Swift例子——构建一个登录页面"><a href="#MVVM-Swift例子——构建一个登录页面" class="headerlink" title="MVVM Swift例子——构建一个登录页面"></a>MVVM Swift例子——构建一个登录页面</h3><p>在这篇文章中，我们将实现一个在View Model中来处理数据的登录功能。对于这个比较，我将忽略自动布局的部分和xib的变化，集中在VC和VM的联系上。现在，让我们开始吧。</p><p><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/03/Screen-Shot-2019-03-17-at-8.29.18-PM.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> emailTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> loginButton: <span class="type">UIButton</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">didTapOnLoginButton</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="keyword">Any</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是在这个启动项目中我所得到的一切。我们有所有的IBOutlet和IBAction——当然，还有两个重要的文件（VM，VC）。</p><p>我们将在这里讨论每个文件。如我们在文章开头所见，我们都知道VC的角色是只做展示和从UI获取信息。我们将在此处应用这些点：</p><ul><li>从UI获取信息：输入框的输入信息</li><li>展示和响应来自VM的数据：点击登录按钮之后，我们将看见一条表示用户是否登录成功的消息。这取决于来自VM的信号</li></ul><p>好了，问题就是我们如何将这两个文件彼此联系起来。有两种常用方法：protocol-delegate和RxSwift。在这一部分，我将谈谈protocol-delegate。这种方法有两个优点：</p><ul><li>非常清楚明确，我们可以知道两个类之间传递的基本信息</li><li>负责任何特定部分的组件将彼此完全独立</li></ul><h4 id="1-从View-Controller发送消息到View-Model"><a href="#1-从View-Controller发送消息到View-Model" class="headerlink" title="1. 从View Controller发送消息到View Model"></a>1. 从View Controller发送消息到View Model</h4><p>这一部分里，有三个步骤：</p><h5 id="步骤1-创建一个ViewModelDelagte的协议"><a href="#步骤1-创建一个ViewModelDelagte的协议" class="headerlink" title="步骤1: 创建一个ViewModelDelagte的协议"></a>步骤1: 创建一个ViewModelDelagte的协议</h5><p>这个协议是View Model的一部分，它有一个函数叫做：<br><code>func sendValue(from emailTextField: String?, passwordTextField: String?)</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ViewModelDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">sendValue</span>(<span class="params">from</span> <span class="params">emailTextField</span>: <span class="type">String</span>?, <span class="params">passwordTextField</span>: <span class="type">String</span>?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-将View-Model连接到视图层"><a href="#步骤2-将View-Model连接到视图层" class="headerlink" title="步骤2: 将View Model连接到视图层"></a>步骤2: 将View Model连接到视图层</h5><p>接着，我们将在view controller中创建一个 viewModel 变量，从这里发送emailTextField和passwordTextField的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> viewModel <span class="operator">=</span> <span class="type">ViewModel</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">didTapOnLoginButton</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="keyword">Any</span>) &#123;</span><br><span class="line">    viewModel.sendValue(from: emailTextField.text, passwordTextField: passwordTextField.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，看起来挺酷，对吧？看起来我们已经将信息打包封装并发送出去了，接下来我们将看到在哪里去接收并解包这个信息。</p><h5 id="步骤3-在View-Model中处理Actions"><a href="#步骤3-在View-Model中处理Actions" class="headerlink" title="步骤3: 在View Model中处理Actions"></a>步骤3: 在View Model中处理Actions</h5><p>在从view controller得到信息之后，我们可以在View Model像这样处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sendValue</span>(<span class="params">from</span> <span class="params">emailTextField</span>: <span class="type">String</span>?, <span class="params">passwordTextField</span>: <span class="type">String</span>?) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> emailTextField <span class="operator">=</span> emailTextField <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> passwordTextField <span class="operator">=</span> passwordTextField <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;emailTextField: <span class="subst">\(emailTextField)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;passwordTextField: <span class="subst">\(passwordTextField)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行并填充一些数据， 看看会发生什么。<br><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/03/Screen-Shot-2019-03-17-at-8.37.43-PM.png"></p><p>可以看到，我接收到了来自VC的“Email Testing”和“Password Testing”。</p><h4 id="2-从view-model发送数据返回到视图层"><a href="#2-从view-model发送数据返回到视图层" class="headerlink" title="2. 从view model发送数据返回到视图层"></a>2. 从view model发送数据返回到视图层</h4><p>让我们先创建另一个叫做<code>ViewControllerDelegate</code>的协议，并让view controller遵循这个协议。这意味着我们不关心view model做了什么，我们只是需要操作的结果。</p><p>这是MVVM巨大的优点。负责VC的不会在乎VM所做的事情，他们只需要结果。同样地，VM不需要知道VC从哪里或如何从UI获取到值，它只关心需要对这些值做什么。因此，所有的关注点都是分离的，从而使所有组件彼此独立。</p><p>在我的例子中，你可以看到编写view model的人将关注的是需要对emailTextField和passwordTextField做的事情，但是不需要知道这些值是从何而来。这个业务逻辑归属于视图层。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ViewControllerDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getInformationBack</span>(<span class="params">handledString</span>: <span class="type">String</span>?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是前文所提到过的，它有一个方法名为<code>getInformationBack</code>。这意味着我们将通过此方法获取到VM所返回的值。</p><p>在ViewModel中，让我们添加一个weak类型的delegate变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">ViewControllerDelegate</span>?</span><br></pre></td></tr></table></figure><p>并将从emailTextField和passwordTextField取回的值发送出去。在此篇教程中，我不会处理任何过于复杂的事情，仅仅只是将两个字符串合并为一，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sendValue</span>(<span class="params">from</span> <span class="params">emailTextField</span>: <span class="type">String</span>?, <span class="params">passwordTextField</span>: <span class="type">String</span>?) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> emailTextField <span class="operator">=</span> emailTextField <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> passwordTextField <span class="operator">=</span> passwordTextField <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;emailTextField: <span class="subst">\(emailTextField)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;passwordTextField: <span class="subst">\(passwordTextField)</span>&quot;</span>)</span><br><span class="line">    delegate<span class="operator">?</span>.getInformationBack(handledString: emailTextField <span class="operator">+</span> passwordTextField)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，到此，我们在处理了值（实际上我们仅仅合并了而已，但是在一个实际的项目中，你可能会做更多的事情比如验证邮箱、密码并告诉VC它们是否可用）之后封装了最后的输出。现在让我们看看如何将数据返回到view controller。</p><p>在VC的<code>viewDidLoad</code>里，添加一行代码：<code>viewModel.delegate = self</code>。还记得我们在VM里有一个delegate变量对吧？这行代码是VC告诉VM它将执行此委托。</p><p>然后，我们只需要实现协议并从VM取回数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ViewController</span>: <span class="title class_">ViewControllerDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getInformationBack</span>(<span class="params">handledString</span>: <span class="type">String</span>?) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> handledString <span class="operator">=</span> handledString <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The string get from VM: <span class="subst">\(handledString)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次编译并运行Xcode项目。现在我们将拥有所需要的一切。我们可以将数据从VC发送到VM，反之亦然。</p><p><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/03/Screen-Shot-2019-03-17-at-8.52.33-PM.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>让我们总结一下我们所做的。在MVVM里，我们将与计算，处理数据等相关的任务分配给了VM。我们仅允许视图层执行UI琐事并从UI和用户交互中获取值。这样，每个设计组件仅负责一个专门的关注点，并且它们彼此完全独立。就这样。我希望在本文之后，您将对MVVM Swift以及如何使用protocol-delegate设计模式进行实现有一个概观。</p><p>MVVM是一个强力的Swift架构模式，它使程序员可以分离其设计组件的关注点，因此，对于任何出色的iOS工程师来说，掌握它都是至关重要的。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于后台任务的选择</title>
      <link href="/2020/03/06/%E5%85%B3%E4%BA%8E%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%80%89%E6%8B%A9/"/>
      <url>/2020/03/06/%E5%85%B3%E4%BA%8E%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>众所周知，iOS 没有真正的后台，而是所谓的“假后台”。那么如果确实有需要在后台完成的任务需要怎么做呢？有如下几种方法可供选择。</p><h3 id="1-在后台继续前台未完成的工作"><a href="#1-在后台继续前台未完成的工作" class="headerlink" title="1. 在后台继续前台未完成的工作"></a>1. 在后台继续前台未完成的工作</h3><p>在某些情况下，用户在前台有未完成任务的时候就将应用切到了后台或者是锁屏，这个时候，任务不会继续执行，除非我们能够让其在后台能够继续执行。<br>比如一个图片下载任务，如果切到了后台，为了让其能够继续下载，需要在开启下载任务的同时开始一个后台任务，这样在应用切到后台的时候，可以在有限时间内继续下载。</p><p>此处使用 <code>UIApplication</code> 的 <code>beginBackgroundTask</code> 方法来开启后台任务。这个方法提供了一个后台任务截止时间的回调并返回一个后台任务标识符，可通过标识符来结束后台任务。如果没有在指定时间内手动结束后台任务，则 <code>expirationHandler</code> 会被调用，这是最后一次能够处理任务的时机，可以发送任务状态的通知等。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">download</span>(<span class="keyword">_</span> <span class="params">url</span>: <span class="type">URL</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> downloadOperation <span class="operator">=</span> <span class="type">DownloadOperation</span>(with: url)</span><br><span class="line"><span class="keyword">let</span> identifier: <span class="type">UIBackgroundTaskIdentifier</span>!</span><br><span class="line">identifier <span class="operator">=</span> <span class="type">UIApplication</span>.shared.beginBackgroundTask(expirationHandler: &#123;</span><br><span class="line">downloadOperation.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Download task not finished.&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">downloadOperation.completionHandler <span class="operator">=</span> &#123;</span><br><span class="line"><span class="type">UIApplication</span>.shared.endBackgroundTask(identifier)</span><br><span class="line">&#125;</span><br><span class="line">downloadOperation.download()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-BackgroundTasks"><a href="#2-BackgroundTasks" class="headerlink" title="2. BackgroundTasks"></a>2. BackgroundTasks</h3><p>在 iOS 13之前，我们使用如下方式来执行后台任务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIApplication</span>.shared.setMinimumBackgroundFetchInterval(<span class="number">60</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">performFetchWithCompletionHandler</span> <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">UIBackgroundFetchResult</span>) -&gt; <span class="type">Void</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>但是在 iOS 13之后，上述方法已经被弃用，被一个新的后台任务框架 <code>BackgroundTasks</code> 所取代。<br><code>BackgroundTasks</code> 有两种后台任务可供选择，一种是 <code>BGProcessingTask</code> ，一般用于处理较为繁重的任务，如数据维护，机器学习模型训练，数据同步等。另外一种是 <code>BGAppRefreshTask</code> ，用于在后台更新应用内容，这样用户每次打开应用时所查看到的内容都是最新的。<code>BGAppRefreshTask</code> 有最多 30 秒的时间来执行更新任务，任务完成之后要调用 <code>setTaskCompleted(success:)</code>，否则系统会终止应用程序。<br>详情请查看 [[BackgroundTasks 实践#^a71227|BackgroundTasks]]</p><h3 id="3-利用推送执行后台任务"><a href="#3-利用推送执行后台任务" class="headerlink" title="3. 利用推送执行后台任务"></a>3. 利用推送执行后台任务</h3><h4 id="3-1-后台推送"><a href="#3-1-后台推送" class="headerlink" title="3.1 后台推送"></a>3.1 后台推送</h4><p>在 iOS7 的时候，苹果允许应用收到通知后在后台状态下运行一段代码，这样应用就可以在不打扰用户的情况下静默更新内容。如果应用会不定期地从服务器获取新内容，在新内容可用时就可使用后台推送来通知我们的应用。<br>推送一个后台通知需要满足如下设置：</p><ul><li><code>content-available</code> 设置为 1；</li><li>不设置 <code>alert</code>、<code>sound</code> 和 <code>badge</code>;</li><li><code>apns-push-type</code> 设置为 <code>background</code>；</li><li><code>apns-priority</code> 设置为5。<br>一个典型的后台 APNs 如下所示：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;aps&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;content-available&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;apns-push-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;apns-priority&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;additional&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background push notification&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>后台通知优先级较低，因此系统并不能保证其一定能被送达。另外要注意时间和频率的限制。一旦应用接收到后台推送，会调用系统代理<code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code>。只有最多 30s 的时间去完成相应的工作，只要完成了后台任务，就要尽可能早地调用  <code>fetchCompletionHandler</code> 以节省电池。苹果建议每小时最多不要发送超过3条后台推送，否则系统会增加速率限制。</li></ul><p>在同一时间，只会存在最新的一条后台推送，如果用户手动杀掉应用程序后台，系统会丢弃已收到的后台通知。如果用户启动了应用程序，则系统会立即发送所收到的通知。</p><blockquote><p><strong>App的状态限制</strong><br>后台推送的前提是应用需处于 background 或 suspended 状态，如果应用是被用户手动杀掉的话则无法被唤醒并处理后台推送。</p></blockquote><h4 id="3-2-推送服务扩展"><a href="#3-2-推送服务扩展" class="headerlink" title="3.2 推送服务扩展"></a>3.2 推送服务扩展</h4><p>通过通知服务扩展，我们也可以在收到通知后进行一些处理后再将通知传达给用户。<br>新建 <code>UNNotificationServiceExtension</code>，当收到通知时，通知服务扩展会被唤醒同时获得后台任务的执行时间。此时 <code>didReceive(_:withContentHandler:)</code>  会被调用，当完成所需要处理的任务时，调用 <code>contentHandler</code> 来结束整个流程。</p><blockquote><p>通知服务扩展需要将推送通知的 <code>mutable-content</code> 设置为1。</p></blockquote><blockquote><p><strong>参考资料</strong><br><a href="https://developer.apple.com/videos/play/wwdc2019/707">Advances in App Background Execution</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI中的Property Wrapper #01</title>
      <link href="/2020/02/12/SwiftUI%E4%B8%AD%E7%9A%84Property-Wrapper-01/"/>
      <url>/2020/02/12/SwiftUI%E4%B8%AD%E7%9A%84Property-Wrapper-01/</url>
      
        <content type="html"><![CDATA[<p>在学习 <code>SwiftUI</code> 的过程中，出现了许多在 <code>Swift</code> 中未曾遇到过的类似 <code>@xxx</code> 的东西，在 <code>SwiftUI</code> 中被称作 <code>Property Wrapper</code>。今天就来学习一下 <code>Property Wrapper</code> 应该怎么使用以及应该什么时候使用。</p><p><code>SwiftUI</code> 中常见的 <code>Property Wrapper</code> 有 <code>@State</code>，<code>@Binding</code>，<code>@ObservedObject</code>，<code>@EnvironmentObject</code> 以及 <code>@Environment</code>等等。接下来就开始分别学习。</p><h3 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h3><p><code>@State</code> 用来描述视图的状态，它所修饰的变量被存储在视图结构之外一个特殊的内部内存空间，只有相关联的视图能够访问。一旦 <code>@State</code> 所修饰的变量发生改变，<code>SwiftUI</code> 将根据所发生的改变重建试图。下面是一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ProductsView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> products: [<span class="type">Product</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> showFavorited: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(</span><br><span class="line">                action: &#123; <span class="keyword">self</span>.showFavorited.toggle() &#125;,</span><br><span class="line">                label: &#123; <span class="type">Text</span>(<span class="string">&quot;Change filter&quot;</span>)&#125;</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="type">ForEach</span>(products) &#123; product <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="operator">!</span><span class="keyword">self</span>.showFavorited <span class="operator">||</span> product.isFavorited &#123;</span><br><span class="line">                    <span class="type">Text</span>(product.title)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，一旦按下按钮，<code>@State</code> 所修饰的<code>showFavorited</code> 的值就发生改变，整个视图也将被重新创建。</p><h3 id="Binding"><a href="#Binding" class="headerlink" title="@Binding"></a>@Binding</h3><p><code>@Binding</code> 为值类型提供了引用访问的方式。有时我们需要使子视图能够访问父视图的状态，但是不能够简单地把值传递过去，因为状态是值类型，SwiftUI 只会传递这个值的一个拷贝。这时候 @Binding 就派上用场了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FilterView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> showFavorited: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(isOn: <span class="variable">$showFavorited</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Change filter&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ProductsView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> products: [<span class="type">Product</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> showFavorited: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">FilterView</span>(showFavorited: <span class="variable">$showFavorited</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">ForEach</span>(products) &#123; product <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="operator">!</span><span class="keyword">self</span>.showFavorited <span class="operator">||</span> product.isFavorited &#123;</span><br><span class="line">                    <span class="type">Text</span>(product.title)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，使用 @Binding 去标记 showFavorited ，这样的话，FilterView 对showFavorited的读写实际就是对ProductsView中的showFavorited进行读写。而根据上一节 @State 所讲到的内容，ProductsView 的 showFavorited 一改变，SwiftUI 就将重新创建此视图。</p><blockquote><p>@Binding只适合对值类型的变量进行修饰，如果对非值类型的变量进行修饰可能会引起未知的错误。</p><p>另外，对 @Binding 修饰的变量传值的时候一定要加上 <code>$</code> 符号，代表是传递的引用，否则就是传递值的拷贝。</p></blockquote><h3 id="ObservedObject"><a href="#ObservedObject" class="headerlink" title="@ObservedObject"></a>@ObservedObject</h3><p>@ObservedObject 是 Combine 框架中的一部分，主要用于处理 SwiftUI 之外的一些事物——比如业务逻辑。可以在不同的独立的视图之间共享、观察和订阅 @ObservedObject 所修饰的变量。一旦变量发生改变，所有绑定此变量的视图都将重建。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PodcastPlayer</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">play</span>() &#123;</span><br><span class="line">        isPlaying <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pause</span>() &#123;</span><br><span class="line">        isPlaying <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PodcastPlayer</code> 可以在多个视图之间共享，在 <code>@Published</code> 属性的帮助下，<code>SwiftUI</code> 可以追踪 <code>@ObservableObject</code> 的变化。一旦 <code>@Published</code> 发生变化，所有绑定 <code>@ObservableObject</code> 的视图都将被重建。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EpisodesView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> player: <span class="type">PodcastPlayer</span></span><br><span class="line">    <span class="keyword">let</span> episodes: [<span class="type">Episode</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(</span><br><span class="line">                action: &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">self</span>.player.isPlaying &#123;</span><br><span class="line">                        <span class="keyword">self</span>.player.pause()</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">self</span>.player.play()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                label: &#123; <span class="type">Text</span>(player.isPlaying <span class="operator">?</span> <span class="string">&quot;Pause&quot;</span>: <span class="string">&quot;Play&quot;</span>) &#125;</span><br><span class="line">            )</span><br><span class="line">            <span class="type">ForEach</span>(episodes) &#123; episode <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(episode.title)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为可以在多个视图之间共享数据，因此 ObservableObject 必须是引用类型。</p></blockquote><h3 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h3><p>@EnvironmentObject 可以将变量隐式地注入到试图层级的环境中。举例说明：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> player <span class="operator">=</span> <span class="type">PodcastPlayer</span>()</span><br><span class="line">window.rootViewController <span class="operator">=</span> <span class="type">UIHostingController</span>(</span><br><span class="line">    rootView: <span class="type">EpisodesView</span>(episode: episodes)</span><br><span class="line">        .environmentObject(player)</span><br><span class="line">)</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EpisodeView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line"><span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> player: <span class="type">PodcastPlayer</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可见，我们可以通过 <code>environmentObject</code> 修饰符来传递 <code>PodcastPlayer</code>，而且可以通过 <code>@EnvironmentObject</code> 轻松地访问。<code>@EnvironmentObject</code> 通过动态成员查找（dynamic member lookup）特性去找到 <code>Environment</code> 中的 <code>PodcastPlayer</code> 实例。这就是为什么不需要在 <code>EpisodesView</code> 初始化的时候传递 <code>PodcastPlayer</code> 实例的原因。</p><h3 id="Environment"><a href="#Environment" class="headerlink" title="@Environment"></a>@Environment</h3><p>前一章节讨论的是将自定义对象传递到 <code>Environment</code> 中，但是 <code>SwiftUI</code> 已经存在许多系统级的设置，通过 <code>@Environment</code> 可以轻松地进行访问。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CalendarView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Environment</span>(\.calendar) <span class="keyword">var</span> calendar: <span class="type">Calendar</span></span><br><span class="line">    <span class="meta">@Environment</span>(<span class="operator">|</span>.locale) <span class="keyword">var</span> locale: <span class="type">Locale</span></span><br><span class="line">    <span class="meta">@Environment</span>(\<span class="operator">/</span>colorScheme) <span class="keyword">var</span> colorScheme: <span class="type">ColorScheme</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Text</span>(locale.identifier)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>@Environment</code> 实现了访问和订阅系统级设置的变化。这些系统设置变化，<code>App</code> 中对应的视图也将被重建。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 属性包装器 </tag>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】减少动态派发提高性能</title>
      <link href="/2018/06/03/%E5%87%8F%E5%B0%91%E5%8A%A8%E6%80%81%E6%B4%BE%E5%8F%91%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/"/>
      <url>/2018/06/03/%E5%87%8F%E5%B0%91%E5%8A%A8%E6%80%81%E6%B4%BE%E5%8F%91%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>和其它许多语言一样，Swift 允许子类覆写父类的方法和属性。这意味着程序需要在运行时才能确定哪个方法和属性被调用和访问。这便是通常称为的动态派发。动态派发增加了语言的可表达性，但是会牺牲恒定的性能时间。这在性能敏感的代码中时不可取的。</p><p>来看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParticleModel</span> &#123;</span><br><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> ( <span class="number">0.0</span>, <span class="number">0.0</span> )</span><br><span class="line"><span class="keyword">var</span> velocity <span class="operator">=</span> <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">updatePoint</span>(<span class="params">newPoint</span>: (<span class="type">Double</span>, <span class="type">Double</span>), <span class="params">newVelocity</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">point <span class="operator">=</span> newPoint</span><br><span class="line">velocity <span class="operator">=</span> newVelocity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">update</span>(<span class="params">newP</span>: (<span class="type">Double</span>, <span class="type">Double</span>), <span class="params">newV</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">updatePoint(newP, newVelocity: newV)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">ParticleModel</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0.0</span>, through: <span class="number">360</span>, by: <span class="number">1.0</span>) &#123;</span><br><span class="line">p.update((i <span class="operator">*</span> sin(i), i), newV:i<span class="operator">*</span><span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，编译器将会执行动态派发，其流程是：</p><ol><li>调用p的update方法</li><li>调用p的updatePoint方法</li><li>获取p的point属性</li><li>获取p的velocity属性</li></ol><p>因为 ParticleModel 的 属性和方法可能会被其子类覆写，所以对 ParticalModel 的属性和方法的访问和调用都是动态派发的。</p><p>在 Swift 里，动态派发的实现是从函数表中查找相应的方法后间接调用。这会比直接调用要慢。另外，间接调用还会阻止许多编译器的优化使得间接调用更耗性能。所以，对于性能要求比较高的代码有几种技巧可以限制动态派发。</p><h3 id="使用-final"><a href="#使用-final" class="headerlink" title="使用 final"></a>使用 final</h3><p>final 关键字可以用在类、方法和属性上，表明这些是不可以被覆写的。这可以让编译器安全地忽略动态派发过程。例如，在下面的代码中，point 和 velocity 将通过对象存储属性的加载直接访问，并通过直接函数调用来调用 updatePoint()。另一方面，update() 因为没有使用 final 关键字，可以被重写，所以将会继续使用动态派发。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParticleModel</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">var</span> point <span class="operator">=</span> ( x: <span class="number">0.0</span>, y: <span class="number">0.0</span> )</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">var</span> velocity <span class="operator">=</span> <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">updatePoint</span>(<span class="params">newPoint</span>: (<span class="type">Double</span>, <span class="type">Double</span>), <span class="params">newVelocity</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">point <span class="operator">=</span> newPoint</span><br><span class="line">velocity <span class="operator">=</span> newVelocity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">update</span>(<span class="params">newP</span>: (<span class="type">Double</span>, <span class="type">Double</span>), <span class="params">newV</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">updatePoint(newP, newVelocity: newV)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以把整个类都加上 final 关键字，这样的话这个类就无法再被子类化，其属性和方法自然也就不可能被重写，所以就不存在动态派发了。</p><h3 id="自动推断为final"><a href="#自动推断为final" class="headerlink" title="自动推断为final"></a>自动推断为final</h3><p>在声明中使用 private 关键字会将可见性限制为当前文件。这样编译器就能轻松地找到所有可以被重写的方法。无法被重写的方法和属性将会被编译器自动推断为使用 final，并删除对方法和属性的间接调用。<br>假设在当前文件里没有类重写 ParticleModel，编译器会替换所有的动态派发为直接调用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParticleModel</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> point <span class="operator">=</span> ( x: <span class="number">0.0</span>, y: <span class="number">0.0</span> )</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> velocity <span class="operator">=</span> <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">updatePoint</span>(<span class="params">newPoint</span>: (<span class="type">Double</span>, <span class="type">Double</span>), <span class="params">newVelocity</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">point <span class="operator">=</span> newPoint</span><br><span class="line">velocity <span class="operator">=</span> newVelocity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">update</span>(<span class="params">newP</span>: (<span class="type">Double</span>, <span class="type">Double</span>), <span class="params">newV</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">updatePoint(newP, newVelocity: newV)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Whole-Module-Optimization"><a href="#使用-Whole-Module-Optimization" class="headerlink" title="使用 Whole Module Optimization"></a>使用 Whole Module Optimization</h3><p>使用默认的权限控制只在声明的模块内可见。因为 Swift 通常是按照模块分别编译的，编译器无法确定一个 internal 的声明是否会在另一个模块中被重写。但是，如果开启了 Whole Module Optimization 的话，所有模块会在一起被编译，这样编译器便可以在编译时判断哪些声明是没有被重写的，因此可以推断出哪些可以使用 final 关键字。<br>还是之前的代码，这次为 ParticalModel 和 update 方法添加上 public 关键字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParticleModel</span> &#123;</span><br><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> ( x: <span class="number">0.0</span>, y: <span class="number">0.0</span> )</span><br><span class="line"><span class="keyword">var</span> velocity <span class="operator">=</span> <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">updatePoint</span>(<span class="params">newPoint</span>: (<span class="type">Double</span>, <span class="type">Double</span>), <span class="params">newVelocity</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">point <span class="operator">=</span> newPoint</span><br><span class="line">velocity <span class="operator">=</span> newVelocity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">update</span>(<span class="params">newP</span>: (<span class="type">Double</span>, <span class="type">Double</span>), <span class="params">newV</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">updatePoint(newP, newVelocity: newV)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">ParticleModel</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0.0</span>, through: times, by: <span class="number">1.0</span>) &#123;</span><br><span class="line">p.update((i <span class="operator">*</span> sin(i), i), newV:i<span class="operator">*</span><span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 Whole Module Optimization 选项编译这段代码时，编译器可以推断出 point，velocity 和 updatePoint() 方法都可以使用 final 关键字。相反，update() 因为声明为 public，所以无法被优化为使用 final。</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息派发 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift字符串的长度问题</title>
      <link href="/2018/05/14/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/14/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="获取的字符串长度不一样？"><a href="#获取的字符串长度不一样？" class="headerlink" title="获取的字符串长度不一样？"></a>获取的字符串长度不一样？</h3><p>在 Swift 中获取字符串的长度很简单，只需要调用 <code>count</code> 属性即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string <span class="operator">=</span> <span class="string">&quot;这是🐘，它的👃很长&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;string 的长度为： <span class="subst">\(string.count)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出: &quot;string 的长度为： 9&quot;</span></span><br></pre></td></tr></table></figure><p>这在日常的使用中是没有什么问题的，直到我在项目中遇到了一个评论 emoji 乱码的问题。<br>问题表现为，在评论的末尾如果是 emoji 的话， 则会变成无法显示的❓，如果 emoji 出现在其它地方，则很少出现这个显示不了的问题。<br>后来经过多次的一步步调试，终于确定是在将字符串转为富文本的时候出现的问题。</p><p>因为评论中包含链接，用户名，以及要调节行高和字间距等等，所以必须要使用富文本来显示，在此处，就简单地写下大概的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">convertToAttributedString</span>(<span class="params">with</span> <span class="params">string</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> attrString <span class="operator">=</span> <span class="type">NSMutableAttributedString</span>(string: string)</span><br><span class="line">    <span class="keyword">let</span> range <span class="operator">=</span> <span class="type">NSMakeRange</span>(<span class="number">0</span>, string.count) <span class="comment">// 1</span></span><br><span class="line">    attrString.addAttribute(<span class="operator">...</span>, value: <span class="operator">...</span>, range: range)</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">return</span> attrString</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convertToAttributedString(with: <span class="string">&quot;今天天气真好啊😄&quot;</span>)</span><br></pre></td></tr></table></figure><p>问题就出现在注释1的地方，先来看看 Swift 的官方文档。</p><blockquote><p>Extended grapheme clusters can be composed of multiple Unicode scalars. This means that different characters—and different representations of the same character—can require different amounts of memory to store. Because of this, characters in Swift don’t each take up the same amount of memory within a string’s representation. As a result, the number of characters in a string can’t be calculated without iterating through the string to determine its extended grapheme cluster boundaries. If you are working with particularly long string values, be aware that the count property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.</p><p>The count of the characters returned by the count property isn’t always the same as the length property of an NSString that contains the same characters. The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.</p></blockquote><p>意思就是有个东西叫做 <code>Extended Grapheme Clusters</code>， 而这个 <code>Extended Grapheme Clusters</code> 是可以由多个 Unicode 标量组成。因此不同的字符或者同一字符的不同表现形式可能需要不同数量的内存来存储。这样就造成了 <code>String</code> 的 <code>count</code> 属性无法准确表示实际所占用的内存大小，而只是我们肉眼所能看到的字符长度。而 <code>NSString</code> 使用的是 UTF-16 字符编码方式，<code>length</code> 表示的是16位代码单元的数量而不是扩展字符集的数量。</p><p>现在再回头看我所遇到的问题就比较清晰明了了，<code>NSMutableAttributedString</code> 与 <code>NSString</code> 的表现形式一样使用 UTF-16。<br>上面的例子中 <code>string.count</code> 的值为 8，而 <code>attrString</code> 在添加属性的时候，按照这个 <code>range</code>，并不能完整地将 emoji 转为富文本，因此 emoji 才会无法显示。</p><p>那么如何修改呢，其实非常简单，只要在计算 range 的时候将 String 转为 NSString，或者使用 UTF-16 的数量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">convertToAttributedString</span>(<span class="params">with</span> <span class="params">string</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> attrString <span class="operator">=</span> <span class="type">NSMutableAttributedString</span>(string: string)</span><br><span class="line">    <span class="keyword">let</span> range1 <span class="operator">=</span> <span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="type">NSString</span>(string: string).length)</span><br><span class="line">    <span class="keyword">let</span> range2 <span class="operator">=</span> <span class="type">NSMakeRange</span>(<span class="number">0</span>, string.utf16.count)</span><br><span class="line">    attrString.addAttribute(<span class="operator">...</span>, value: <span class="operator">...</span>, range: range1)</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">return</span> attrString</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convertToAttributedString(with: <span class="string">&quot;今天天气真好啊😄&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在使用 <code>range1</code> 或者 <code>range2</code> 转换为富文本就不会再出现末尾 emoji 乱码的问题了。</p><h3 id="中英文限制字数的问题"><a href="#中英文限制字数的问题" class="headerlink" title="中英文限制字数的问题"></a>中英文限制字数的问题</h3><p>既然都说到字符串长度的问题了，顺便再讨论下另外以一个问题。  </p><p>相信在日常的工作中，我们都不免会遇到要限制输入字数的问题。通用的做法都是在 <code>textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool</code> 中计算 textField.text.count 和 string.count 之和，如果数字超过了限制的最大字数，则返回 false，不再允许用户输入。</p><p>这种做法一般来说没什么问题，但是如果老板告诉你中文限制100字，英文限制200字，那么应该怎么办呢？</p><p>我们先来看看，不同的编码方式是怎么来存储字符的。</p><ul><li>UTF-8：一个英文字符占用一个字节，一个中文占用三个字节。</li><li>UTF-16：一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要4 个字节）</li><li>UTF-32：使用 4 个字节表示一个字符。</li><li>GBK：一个英文占用一个字节，一个中文占用两个字节。</li><li>GB2312：一个英文占用一个字节，一个中文占用两个字节。</li></ul><p><em><strong>此处只是简单地认识一下不同编码方式下中英文所占用的内存空间大小，想更深入了解请查询字符编码相关详细资料。</strong></em></p><p>从上面可以看出，如果使用GBK 编码和 GB2312 编码，那么只需要计算出所占用的字节数， 就可以变相地达到限制中英文不同字数的需求。比如说，如果在 <code>UITextField</code> 的代理中限制字节数为 20，那么就只能输入 10 个中文文字或 20 个英文字母或者 5 个中文和 10 个英文字母。</p><p>下面则是计算所占用字节数的计算方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getBytesCount</span>(<span class="params">of</span> <span class="params">string</span>: <span class="type">String</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> encoding <span class="operator">=</span> <span class="type">CFStringConvertEncodingToNSStringEncoding</span>(<span class="type">CFStringEncoding</span>(<span class="type">CFStringEncodings</span>.<span class="type">GB_18030_2000</span>.rawValue))</span><br><span class="line">    <span class="keyword">let</span> data <span class="operator">=</span> string.data(using: <span class="type">String</span>.<span class="type">Encoding</span>(rawValue: encoding))<span class="operator">!</span></span><br><span class="line">    <span class="keyword">return</span> data.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是针对中英文限制字数不同的解决方案了。</p><hr><p>参考资料：</p><p><a href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html">Swift 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> NSString </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 点滴【持续更新】</title>
      <link href="/2018/03/15/iOS%20%E7%82%B9%E6%BB%B4%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91/"/>
      <url>/2018/03/15/iOS%20%E7%82%B9%E6%BB%B4%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E4%BD%93">动态加载字体</a></li></ul><!-- /TOC --><h3 id="动态加载字体"><a href="#动态加载字体" class="headerlink" title="动态加载字体"></a>动态加载字体</h3><p>在一些阅读类的应用中，可能会有更换字体的需求。常规的字体更换是将字体文件添加到项目中，并在 <code>Info.plist</code> 文件中添加好参数。此处的字体添加方式为从服务器下载字体并添加，不用设置 <code>Info.plist</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreGraphics</span><br><span class="line"><span class="keyword">import</span> CoreText</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">loadFont</span>(<span class="keyword">_</span> <span class="params">fontName</span>: <span class="type">String</span>, <span class="params">size</span>: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">14</span>) -&gt; <span class="type">UIFont</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">UIFont</span>?</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取本地字体文件</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> path <span class="operator">=</span> <span class="type">Bundle</span>.main.path(forResource: fontName, ofType: <span class="string">&quot;ttf&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data <span class="operator">=</span> <span class="type">NSData</span>(contentsOfFile: path), <span class="keyword">let</span> fontData <span class="operator">=</span> data <span class="keyword">as?</span> <span class="type">CFData</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 CGDataProvider 生成 CGFont 对象</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> fontDataProvider <span class="operator">=</span> <span class="type">CGDataProvider</span>(data: fontData) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> fontRef <span class="operator">=</span> <span class="type">CGFont</span>(fontDataProvider) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册字体</span></span><br><span class="line">        <span class="keyword">var</span> error <span class="operator">=</span> <span class="type">Unmanaged</span>&lt;<span class="type">CFError</span>&gt;?(nilLiteral: ())</span><br><span class="line">        <span class="type">CTFontManagerRegisterGraphicsFont</span>(fontRef, <span class="operator">&amp;</span>error)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字体的实际名称</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> realFontName <span class="operator">=</span> fontRef.fullName <span class="keyword">as?</span> <span class="type">String</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> font <span class="operator">=</span> <span class="type">UIFont</span>(name: realFontName, size: size) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        result <span class="operator">=</span> font</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 的消息派发</title>
      <link href="/2018/03/07/Swift-%E7%9A%84%E6%B6%88%E6%81%AF%E6%B4%BE%E5%8F%91/"/>
      <url>/2018/03/07/Swift-%E7%9A%84%E6%B6%88%E6%81%AF%E6%B4%BE%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>什么是消息派发？所谓的消息派发就是当调用一个方法时程序如何选择指令去执行。</p><p>编译型语言有三种主要的派发方法。</p><ol><li><a href="#%E7%9B%B4%E6%8E%A5%E6%B4%BE%E5%8F%91">直接派发</a></li><li><a href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E6%B4%BE%E5%8F%91">函数表派发</a></li><li><a href="#%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B4%BE%E5%8F%91">动态派发</a></li></ol><h3 id="直接派发"><a href="#直接派发" class="headerlink" title="直接派发"></a>直接派发</h3><p>直接派发是最快速的派发方式，这不仅是因为它产生的汇编指令少，更是因为编译器会执行各种技巧，比如说内联代码。<br>但是，从编码的角度来看，直接派发也是最受限制的，它不够动态，无法支持子类化。<br>Swift 的一大优势是支持值类型，而值类型的方法都是通过直接派发的方式进行调用的。另外，添加了 <code>final</code> 关键字的方法和在 <code>extension</code> 中实现的方法也是直接派发的。如果要归纳总结一下的话，那就是无法被继承重写的方法都是直接派发的。</p><h3 id="函数表派发"><a href="#函数表派发" class="headerlink" title="函数表派发"></a>函数表派发</h3><p>函数表派发是编译语言中最常见的动态行为实现。动态派发会为类中定义的每一个可重写方法创建一个函数指针数组。大多数语言将其称为虚拟表(Virtual Method Table，即VTable)，但 Swift 使用另一个术语“见证表”。对于被重写的方法，每个子类都会持有一份不同于父类的函数指针。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">method1</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">method2</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>: <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">method2</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">method3</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码，在 <code>ClassA</code> 中，创建了一个数组来存储函数指针，此处假设函数指针排列如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法名          地址</span><br><span class="line">method1        0x100</span><br><span class="line">method2        0x101</span><br></pre></td></tr></table></figure><p>再来看看<code>ClassB</code>中的函数指针排列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法名           地址</span><br><span class="line">method1         0x100</span><br><span class="line">method2         0x201</span><br><span class="line">method3         0x202</span><br></pre></td></tr></table></figure><p>因为<code>ClassB</code>中的重写了method2，所以method2的指针地址被重新生成，而method1还是保持不变，新增的方法地址被添加到数组的末尾。<br>这种派发方式相比直接派发依然很慢。从字节码的角度来看，这里存在两次额外的读取和一次跳转造成一些开销。而被认为很慢的另一个原因是编译器无法根据方法内部的情况执行任何优化。<br>这种基于数组的实现的一个缺点就是 <code>extension</code> 不能向函数表中继续添加指针。由于子类将新方法到函数表的末尾，因此也就没有位置让扩展安全地将函数指针添加进来。</p><p>而在 protocol 中定义的方法，则会另外生成一个 witness table，即 <code>WTable</code>。需要注意的是，遵循协议的对象必须明确指定协议类型才会从 <code>WTable</code> 查找方法调用，否则会由于类型推导而使用对象本身的派发方式。</p><h3 id="消息机制派发"><a href="#消息机制派发" class="headerlink" title="消息机制派发"></a>消息机制派发</h3><p>消息派发是最动态的类型，也是最慢的一种。动态派发中函数表在编译期间生成，而消息派发则只能在运行时才能确定具体调用的是哪个方法，比如说可能存在的方法交换和动态添加等。Cocoa 框架中大量使用了消息机制来做派发，比如说KVO、Core Data等等。</p><p>当消息被分发时，runtime 会在类的层次结构中去寻找确定哪个方法被调用。这并不是特别慢，因为其是由高性能缓存实现的。</p><blockquote><p>编译器总是尝试将派发方式升级为静态派发，除非手动指定了<code>dynamic</code>和<code>@objc</code>关键字。</p></blockquote><p>那么 Swift 到底是按照什么规则进行消息派发的呢？<br><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRp-XlFE4_jF7f4wpLJb_Q.png" alt="派发规则"><br>由上图可以总结出如下规则：</p><ul><li>值类型始终使用直接派发</li><li>类和协议的扩展都使用直接派发</li><li>NSObject 的声明作用域里的方法使用函数表派发</li><li>协议中声明的拥有默认实现的方法使用函数表派发</li><li>NSObject 扩展中的方法使用消息机制进行派发</li></ul><h3 id="手动指定派发方式"><a href="#手动指定派发方式" class="headerlink" title="手动指定派发方式"></a>手动指定派发方式</h3><p> Swift 中有一些关键字可以指定方法的派发方式。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p> 使用直接派发，不会生成对应的 selector，因此使用runtime会获取不到使用 final 修饰的方法。</p><h4 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h4><p> 可以让方法具有动态性，runtime可以获取到，使用消息机制派发。另外一点就是使用 dynamic 可以让 extension 里面的方法也能够被 override。</p><h4 id="objc-amp-nonobjc"><a href="#objc-amp-nonobjc" class="headerlink" title="@objc &amp; @nonobjc"></a>@objc &amp; @nonobjc</h4><p> 标记方法是否能被runtime获取到，@objc使用消息机制派发，@nonobjc则是禁止使用消息机制派发。</p><h4 id="final-objc"><a href="#final-objc" class="headerlink" title="final @objc"></a>final @objc</h4><p> 这两个关键字同时使用时，既可以使用直接派发，也可以生成对应的 selector，在OC中可以使用runtime获取到对应的方法。兼具了静态与动态特性。</p><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p> 该关键字会告诉编译器使用直接派发。</p><p>关于关键字和对应的派发方法可以参考如下表格：<br><img src="https://gist.githubusercontent.com/KingOfBrian/778dc93bffddf25b2c414360727c273b/raw/e9fde1cb8f9c1cee9e4d043a30b01c3a74b91e6e/Summary.png" alt="派发方法"></p><p>可以通过 SIL 来查看测试代码具体的派发方式，生成 SIL 的方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc -emit-silgen -Onone DispatchTest.swift | xcrun swift-demangle &gt;&gt; result.sil</span><br></pre></td></tr></table></figure><blockquote><p>参考文章</p><p><a href="https://gist.github.com/KingOfBrian/778dc93bffddf25b2c414360727c273b">Swift Dispatch</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息派发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融类 App 中的数字精度问题</title>
      <link href="/2018/03/04/%E9%87%91%E8%9E%8D%E7%B1%BB-App-%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/04/%E9%87%91%E8%9E%8D%E7%B1%BB-App-%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在交易市场中，一分一厘都是很重要的，要是开发的时候来个向上向下取整或者四舍五入就会造成纠纷。因此在开发金融类 app 时对数字的精度要求是至关重要的。</p><p>而众所周知，计算机中的浮点数计算是不精确的，比如在 Swift 中 <code>print(0.1 + 0.2)</code> 这句代码执行的结果是 <code>0.30000000000000004</code> 而不是 <code>0.3</code>。产生此种结果的原因此处不再赘述，只说解决的方案。</p><h3 id="NSDecimalNumber"><a href="#NSDecimalNumber" class="headerlink" title="NSDecimalNumber"></a>NSDecimalNumber</h3><p><code>NSDecimalNumber</code> 可以用来处理的浮点数的精度问题。它可以使用 <code>Double</code> 类型或者字符串来进行初始化，支持基本的四则运算。对应的方法如下：</p><ul><li>加法：&#96;adding(_:)</li><li>减法：<code>subtracting(_:)</code></li><li>乘法：<code>multiplying(by:)</code></li><li>除法：<code>dividing(by:)</code><br>当然，还有其它的一些用法，但是此处只列举常用的一些方法。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberA <span class="operator">=</span> <span class="type">NSDecimalNumber</span>(value: <span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">let</span> numberB <span class="operator">=</span> <span class="type">NSDecimalNumber</span>(value: <span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> numberA.adding(numberB)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>这下再运行，可以看到输出结果为 <code>0.3</code>。</p><p>如果是购买东西，假如单价是1.99，数量是2.5，那么结果是4.975，我们要保留两位小数，这时候就要引入 behavior 了。<br>还是上面的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> behavior <span class="operator">=</span> <span class="type">NSDecimalNumberHandler</span>(</span><br><span class="line">    roundingMode: .bankers,</span><br><span class="line">    scale: <span class="number">2</span>,</span><br><span class="line">    raiseOnExactness: <span class="literal">false</span>,</span><br><span class="line">    raiseOnOverflow: <span class="literal">false</span>,</span><br><span class="line">    raiseOnUnderflow: <span class="literal">false</span>,</span><br><span class="line">    raiseOnDivideByZero: <span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> numberA <span class="operator">=</span> <span class="type">NSDecimalNumber</span>(value: <span class="number">1.99</span>)</span><br><span class="line"><span class="keyword">let</span> numberB <span class="operator">=</span> <span class="type">NSDecimalNumber</span>(value: <span class="number">2.5</span>)</span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> numberA.multiplying(by: numberB, withBehavior: behavior)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>此时输出的结果为 4.98。<br>此段代码中在两个数相乘时添加了一个 <code>behavior</code> 参数，而 <code>behavior</code> 是一个 <code>NSDecimalNumberHandle</code> 类型。 在这里主要看前两个参数。<br>第一个是确定小数保留的类型，一共有如下几种：</p><ul><li>NSRoundPlain，四舍五入  </li><li>NSRoundDown，只舍不入  </li><li>NSRoundUp，只入不舍  </li><li>NSRoundBankers，四舍六入，当为5时，确保舍去之后的小数最后一位为偶数<br>具体的示例如下图表所示：<br><img src="https://s1.ax1x.com/2023/03/05/ppEt6w6.png" alt="精度设置"></li></ul><p>第二个参数则是设置保留的小数位数，但是不会自动补零，如果需要补零则需要在转为字符串时进行格式化后显示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(format: <span class="string">&quot;%.2f&quot;</span>, result.doubleValue))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NSDecimalNumber </tag>
            
            <tag> 精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中二维码的识别</title>
      <link href="/2017/09/16/iOS%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E8%AF%86%E5%88%AB/"/>
      <url>/2017/09/16/iOS%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><blockquote><p><strong>二维条码</strong>是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，而其长度没有记载数据。二维条码的长度、宽度均记载着数据。</p><p>二维条码在商业活动中应用广泛，特别是在高科技行业、储存运输业、批发零售业等需要对物品进行廉价快捷的标示信息的行业用途广泛。</p></blockquote><p>闲话少叙，二维码的应用已经到了无孔不入的地步，只要是个规模稍大点儿的APP就基本支持二维码的识别，所以，本文就讲讲二维码的识别。</p><span id="more"></span><h3 id="UI绘制"><a href="#UI绘制" class="headerlink" title="UI绘制"></a>UI绘制</h3><p>常规的二维码扫描界面是一个灰色的背景和一个正方形的白框来确定二维码的位置。在此我们使用贝塞尔曲线来画出形状，用<code>CAShapeLayer</code>来进行展示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path1 <span class="operator">=</span> <span class="type">UIBezierPath</span>(rect: <span class="keyword">self</span>.view.bounds)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二条path用来绘制正方形</span></span><br><span class="line"><span class="keyword">let</span> x <span class="operator">=</span> (<span class="keyword">self</span>.view.bounds.size.width <span class="operator">-</span> <span class="number">200</span>) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> path2 <span class="operator">=</span> <span class="type">UIBezierPath</span>(rect: <span class="type">CGRect</span>(x: x, y: <span class="number">150</span>, width: <span class="number">200</span>, height: <span class="number">200</span>))</span><br><span class="line"></span><br><span class="line">path1.append(path2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shape <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line">shape.path <span class="operator">=</span> path1.cgPath</span><br><span class="line"><span class="comment">// 设置填充规则</span></span><br><span class="line">shape.fillRule <span class="operator">=</span> kCAFillRuleEvenOdd</span><br><span class="line">shape.fillColor <span class="operator">=</span> <span class="type">UIColor</span>.lightGray.cgColor</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.view.layer.addSublayer(shape)</span><br></pre></td></tr></table></figure><p>到此，扫描二维码的界面就算是构建完了。</p><h3 id="摄像头扫描二维码"><a href="#摄像头扫描二维码" class="headerlink" title="摄像头扫描二维码"></a>摄像头扫描二维码</h3><p>要使用摄像头扫描二维码，首先需要获取相机的授权。如果没有得到授权，应该提示用户在权限设置中打开相机的权限。</p><h4 id="检查相机授权"><a href="#检查相机授权" class="headerlink" title="检查相机授权"></a>检查相机授权</h4><p>首先需要检查当前相机的授权状态，授权状态是一个枚举类型，根据不同的枚举值判断下一步应该要做的是什么。</p><ul><li><p>notDetermined，表示还没有发起过授权请求；</p></li><li><p>authorized，表示已经取得了授权；</p></li><li><p>denied，表示已经拒绝了授权；</p></li><li><p>restricted，表示主动限制。</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">checkCameraAuthorization</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> status <span class="operator">=</span> <span class="type">AVCaptureDevice</span>.authorizationStatus(for: .video)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> status &#123;</span><br><span class="line">        <span class="keyword">case</span> .notDetermined:</span><br><span class="line">            <span class="type">AVCaptureDevice</span>.requestAccess(for: .video, completionHandler: &#123; (granted) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> granted &#123;</span><br><span class="line">                    <span class="comment">// 如果拿到了相机授权，可以进行下一步</span></span><br><span class="line">                    <span class="keyword">self</span>.setupCamera()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .authorized:</span><br><span class="line">            <span class="keyword">self</span>.setupCamera()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .denied:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;前往系统设置打开app相机权限&quot;</span>)</span><br><span class="line">            <span class="comment">// 此处需要在URL Types中添加一个prefs的URL Schemes</span></span><br><span class="line">            <span class="type">UIApplication</span>.shared.openURL(<span class="type">URL</span>.<span class="keyword">init</span>(string: <span class="string">&quot;hello&quot;</span>)<span class="operator">!</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .restricted:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Camera cannot be used.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相机设置"><a href="#相机设置" class="headerlink" title="相机设置"></a>相机设置</h4><p>相机设置包括device、session、input和output的设置，其中最主要的是<code>rectOfInterest</code>的设置。<code>rectOfInterest</code>是一个<code>CGRect</code>类型的属性，但是它的坐标原点是在右上角，取值范围是0~1。也就是说右上角坐标为（0，0），左下角坐标是（1，1）。为了方便设置，此处谢了一个坐标转换的函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将常规rect转换为相机的识别rect</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - rect: 待转换的常规rect</span></span><br><span class="line"><span class="comment">///   - parentSize: 所在的父视图的size</span></span><br><span class="line"><span class="comment">/// - Returns: 转换后的rect</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">transaction</span>(<span class="params">rect</span>: <span class="type">CGRect</span>, <span class="params">parentSize</span>: <span class="type">CGSize</span>) -&gt; <span class="type">CGRect</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x <span class="operator">=</span> (parentSize.width <span class="operator">-</span> rect.origin.x) <span class="operator">/</span> parentSize.width</span><br><span class="line">    <span class="keyword">let</span> y <span class="operator">=</span> rect.origin.y <span class="operator">/</span> parentSize.height</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> width <span class="operator">=</span> rect.size.width <span class="operator">/</span> parentSize.width</span><br><span class="line">    <span class="keyword">let</span> height <span class="operator">=</span> rect.size.height <span class="operator">/</span> parentSize.height</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGRect</span>(x: x, y: y, width: width, height: height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，检查back camera是否存在，设置session，input和output，最后设置显示相机捕获内容的<code>AVCaptureVideoPreviewLayer</code>并将其添加到父视图上去。最后调用<code>session</code>的<code>startRunning</code>方法开始捕捉。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">setupCamera</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> devices <span class="operator">=</span> <span class="type">AVCaptureDevice</span>.devices(for: .video)</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> devices &#123;</span><br><span class="line">        <span class="keyword">if</span> obj.position <span class="operator">==</span> .back &#123;</span><br><span class="line">            <span class="keyword">self</span>.device <span class="operator">=</span> obj</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.device <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Unavailabel back camera.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> input <span class="operator">=</span> <span class="keyword">try!</span> <span class="type">AVCaptureDeviceInput</span>.<span class="keyword">init</span>(device: <span class="keyword">self</span>.device<span class="operator">!</span>)</span><br><span class="line">    <span class="keyword">let</span> output <span class="operator">=</span> <span class="type">AVCaptureMetadataOutput</span>()</span><br><span class="line"></span><br><span class="line">    output.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>.main)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在此处获取UI上画的白框rect，然后通过上面所写的函数进行坐标转换</span></span><br><span class="line">    <span class="keyword">let</span> x <span class="operator">=</span> (<span class="keyword">self</span>.view.bounds.size.width <span class="operator">-</span> <span class="number">200</span>) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> rect <span class="operator">=</span> <span class="type">CGRect</span>(x: x, y: <span class="number">150</span>, width: <span class="number">200</span>, height: <span class="number">200</span>))</span><br><span class="line">    output.rectOfInterest <span class="operator">=</span> <span class="keyword">self</span>.transaction(rect: rect, parentSize: <span class="keyword">self</span>.view.bounds.size)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置识别对象为二维码</span></span><br><span class="line">    output.metadataObjectTypes <span class="operator">=</span> [.qr]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.session <span class="operator">=</span> <span class="type">AVCaptureSession</span>()</span><br><span class="line">    <span class="keyword">self</span>.session<span class="operator">?</span>.sessionPreset <span class="operator">=</span> .high</span><br><span class="line">    <span class="keyword">self</span>.session<span class="operator">?</span>.addInput(input)</span><br><span class="line">    <span class="keyword">self</span>.session<span class="operator">?</span>.addOutput(output)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> previewLayer <span class="operator">=</span> <span class="type">AVCaptureVideoPreviewLayer</span>.<span class="keyword">init</span>(session: <span class="keyword">self</span>.session<span class="operator">!</span>)</span><br><span class="line">    <span class="keyword">self</span>.view.layer.insertSublayer(previewLayer, at: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">self</span>.session<span class="operator">?</span>.startRunning()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出代理"><a href="#输出代理" class="headerlink" title="输出代理"></a>输出代理</h4><p>如果扫描到二维码，那么将会调用扫描成功的代理方法，通过获取扫描到的<code>metadataObjects</code>数组来获得最终的扫描文字内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">metadataOutput</span>(<span class="keyword">_</span> <span class="params">output</span>: <span class="type">AVCaptureMetadataOutput</span>, <span class="params">didOutput</span> <span class="params">metadataObjects</span>: [<span class="type">AVMetadataObject</span>], <span class="params">from</span> <span class="params">connection</span>: <span class="type">AVCaptureConnection</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> object: <span class="type">AVMetadataMachineReadableCodeObject</span> <span class="operator">=</span> metadataObjects.first <span class="keyword">as!</span> <span class="type">AVMetadataMachineReadableCodeObject</span></span><br><span class="line">    <span class="built_in">print</span>(object.stringValue <span class="keyword">as</span> <span class="keyword">Any</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片识别二维码"><a href="#图片识别二维码" class="headerlink" title="图片识别二维码"></a>图片识别二维码</h3><p>图片识别相当简单，识别二维码主要会用到<code>CoreImage</code>中的<code>CIDectector</code>类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">scanQRCode</span>(<span class="params">image</span>: <span class="type">UIImage</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> detector <span class="operator">=</span> <span class="type">CIDetector</span>.<span class="keyword">init</span>(ofType: <span class="type">CIDetectorTypeQRCode</span>, context: <span class="literal">nil</span>, options: [CIDetectorAccuracy: <span class="type">CIDetectorAccuracyHigh</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> detector<span class="operator">?</span>.features(in: image.ciImage<span class="operator">!</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> result <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cannot detect QRCode on the image.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> result &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Message is <span class="subst">\(feature.messageString)</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用闪光灯"><a href="#使用闪光灯" class="headerlink" title="使用闪光灯"></a>使用闪光灯</h3><p>在黑暗环境下，使用相机扫描二维码时，会需要有光源照明，比如夜晚扫摩拜、ofo之类的场景。此时就会需要打开闪光灯。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">flashLight</span>(<span class="params">sender</span>: <span class="type">UIButton</span>) &#123;</span><br><span class="line">    sender.isSelected <span class="operator">=</span> <span class="operator">!</span>sender.isSelected</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.session<span class="operator">?</span>.beginConfiguration()</span><br><span class="line">    <span class="keyword">self</span>.device<span class="operator">?</span>.lockForConfiguration()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.device<span class="operator">?</span>.torchMode <span class="operator">=</span> sender.isSelected <span class="operator">?</span> .on : .off</span><br><span class="line">    <span class="keyword">self</span>.device<span class="operator">?</span>.flashMode <span class="operator">=</span> sender.isSelected <span class="operator">?</span> .on : .off</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.device<span class="operator">?</span>.unlockForConfiguration()</span><br><span class="line">    <span class="keyword">self</span>.session<span class="operator">?</span>.commitConfiguration()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续会补充根据光线强度自动打开闪光灯的部分。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中绘制SVG（二）：path命令的绘制</title>
      <link href="/2017/08/26/iOS%E4%B8%AD%E7%BB%98%E5%88%B6SVG%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Apath%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BB%98%E5%88%B6/"/>
      <url>/2017/08/26/iOS%E4%B8%AD%E7%BB%98%E5%88%B6SVG%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Apath%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Path 命令的绘制分为两个部分，第一步是解析 path 的命令和参数，第二部是根据解析出的数据生成正确的贝塞尔曲线然后进行绘制。</p><p>Path 命令一共有 10 个子命令，并且区分大小写，大写代表绝对定位，小写代表相对定位，为了方便描述，在下文所有命令都以大写表示，只在代码中进行大小写——即相对定位和绝对定位的区分。</p><ul><li>M：移动命令，即 move；</li><li>L：线段命令，即 line；</li><li>H：根据上一条 path 的终点添加一条水平方向的线段；</li><li>V：根据上一条 path 的终点添加一条垂直方向的线段；</li><li>A：添加一段弧线；</li><li>C：添加一段 curve，即二次贝塞尔曲线；</li><li>Q：添加一段 quad curve，即三次贝塞尔曲线；</li><li>S：在 C 命令后追加一段镜像 curve；</li><li>T：在 Q 命令后追加一段镜像 quad curve；</li><li>Z：close 当前的path。</li></ul><span id="more"></span><p>接下来就开始 path 命令具体的解析和绘制过程。</p><h3 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h3><h4 id="扫描命令和参数"><a href="#扫描命令和参数" class="headerlink" title="扫描命令和参数"></a>扫描命令和参数</h4><p>首先，path 命令以一个字符串的形式表示，因为在 path 中都是以 command 加上参数的形式，所以在此需要使用到<code>NSScanner</code>这个类来进行扫描相应的命令和参数。</p><p>先将所有的命令分大小写拼接成一个字符串——“MLHVACQSTZmlhvacqstz”，然后利用<code>scanCharactersFromSet:</code>方法扫描子命令，如果扫描到命令的话继续利用<code>scanDouble:</code>扫描命令后面所跟的参数，参数扫描结束后开始生成本次命令的贝塞尔曲线。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSScanner</span> *scanner = [<span class="built_in">NSScanner</span> scannerWithString:commandStr];</span><br><span class="line"><span class="built_in">NSCharacterSet</span> *skipSet = [<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@&quot; ,\n&quot;</span>];</span><br><span class="line">scanner.charactersToBeSkipped = skipSet;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCharacterSet</span> *commandSet = [<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@&quot;MLACQSTHVZmlacqsthvz&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *command = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ([scanner scanCharactersFromSet:commandSet intoString:&amp;command]) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *numbers = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="type">double</span> number = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> ([scanner scanDouble:&amp;number]) &#123;</span><br><span class="line">        [numbers addObject:@(number)];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> executeCommand:[command UTF8String] Numbers:[numbers <span class="keyword">copy</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行对应的命令"><a href="#执行对应的命令" class="headerlink" title="执行对应的命令"></a>执行对应的命令</h4><p>然后在<code>executeCommand:(const char *)command Numbers:(NSArray&lt;NSNumber *&gt; *)nums</code>方法中根据具体命令的大小写来执行对应的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)executeCommand:(<span class="keyword">const</span> <span class="type">char</span> *)command Numbers:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *)nums &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (command[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> move:nums Relative:<span class="literal">NO</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> move:nums Relative:<span class="literal">YES</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addLine:nums Relative:<span class="literal">NO</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addLine:nums Relative:<span class="literal">YES</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addArc:nums Relative:<span class="literal">NO</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addArc:nums Relative:<span class="literal">YES</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addCurve:nums Relative:<span class="literal">NO</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addCurve:nums Relative:<span class="literal">YES</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addQuad:nums Relative:<span class="literal">NO</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addQuad:nums Relative:<span class="literal">YES</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addSmoothCurve:nums Relative:<span class="literal">NO</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addSmoothCurve:nums Relative:<span class="literal">YES</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addSmoothQuad:nums Relative:<span class="literal">NO</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addSmoothQuad:nums Relative:<span class="literal">YES</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addHorizon:nums Relative:<span class="literal">NO</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addHorizon:nums Relative:<span class="literal">YES</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addVertical:nums Relative:<span class="literal">NO</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> addVertical:nums Relative:<span class="literal">YES</span>];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">          [<span class="keyword">self</span> close];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;cannot resolve command.&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，path 的解析就已经完成了。</p><h3 id="绘制path"><a href="#绘制path" class="headerlink" title="绘制path"></a>绘制path</h3><p>由于需要保存绘制过程中的一些变量，因此会声明几个全局变量在绘制过程中进行保存数据。</p><ul><li>由于存在相对位置，所以需要<code>CGPoint</code>类型的<code>lastPoint</code>来保存前一path的终点；</li><li>由于T命令需要根据上一条路径推断控制点，所以需要<code>CGPoint</code>类型的<code>preQCtrl</code>来记录上一条二次贝塞尔曲线的控制点；</li><li>由于 S 命令同T命令一样，所以需要<code>CGPoint</code>类型的<code>preCCtrl</code>来记录上一条三次贝塞尔曲线的第一个控制点；</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGPoint</span> lastPoint;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGPoint</span> preQCtrl;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGPoint</span> preCCtrl;</span><br></pre></td></tr></table></figure><h4 id="M命令"><a href="#M命令" class="headerlink" title="M命令"></a>M命令</h4><p>M 命令后面会跟着一个坐标，意思是将画笔移动到所给坐标的位置，path 将以这个坐标为起点。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// M命令格式如下：&quot;M10 10&quot;</span></span><br><span class="line"><span class="built_in">CGPoint</span> p = <span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是相对定位，需要加上上一 path 的终点</span></span><br><span class="line"><span class="keyword">if</span> (relative) &#123;</span><br><span class="line">    p = <span class="built_in">CGPointMake</span>(lastPoint.x + p.x, lastPoint.y + p.y);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.path moveToPoint:p];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在绘制完成后，需要将记录 path 终点的 lastPoint 指向新的终点，后面除了 Z 以外的所有命令都相同，不再赘述。</span></span><br><span class="line">lastPoint = p;</span><br></pre></td></tr></table></figure><h4 id="L命令"><a href="#L命令" class="headerlink" title="L命令"></a>L命令</h4><p>L 命令将会在上一 path 的终点和给定的点之间画一条直线。L 命令添加一条直线，其后同样是跟着一个点的坐标，这个坐标点是直线的终点。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L命令格式如下：&quot;L 10 10&quot;</span></span><br><span class="line"><span class="built_in">CGPoint</span> p = <span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (relative) &#123;</span><br><span class="line">    p = <span class="built_in">CGPointMake</span>(lastPoint.x + p.x, lastPoint.y + p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.path addLineToPoint:p];</span><br><span class="line"></span><br><span class="line">lastPoint = p;</span><br></pre></td></tr></table></figure><h4 id="H命令"><a href="#H命令" class="headerlink" title="H命令"></a>H命令</h4><p>H 代表着 horizon，意思是画一条水平方向的直线。H 命令后面会跟一个数字，数字代表 x 坐标，y 坐标与前一坐标的 y 坐标相同。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// H命令格式如下：&quot;H 90&quot;</span></span><br><span class="line"><span class="built_in">CGPoint</span> p = <span class="built_in">CGPointMake</span>(<span class="number">90</span>, lastPoint.y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (relative) &#123;</span><br><span class="line">    p = <span class="built_in">CGPointMake</span>(lastPoint.x + p.x, lastPoint.y);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.path addLineToPoint:p];</span><br><span class="line"></span><br><span class="line">lastPoint = p;</span><br></pre></td></tr></table></figure><h4 id="V命令"><a href="#V命令" class="headerlink" title="V命令"></a>V命令</h4><p>V 代表 vertical，意思是画一条垂直方向的直线。V 命令格式同 H 命令一样。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V命令格式如下：&quot;V 90&quot;</span></span><br><span class="line"><span class="built_in">CGPoint</span> p = <span class="built_in">CGPointMake</span>(lastPoint.x, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (relative) &#123;</span><br><span class="line">    p = <span class="built_in">CGPointMake</span>(lastPoint.x, lastPoint.y + p.y);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.path addLineToPoint:p];</span><br><span class="line"></span><br><span class="line">lastPoint = p;</span><br></pre></td></tr></table></figure><h4 id="Q命令"><a href="#Q命令" class="headerlink" title="Q命令"></a>Q命令</h4><p>Q 命令用来创建二次贝塞尔曲线，关于贝塞尔曲线，可以去<a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A#.E4.BA.8C.E6.AC.A1.E6.96.B9.E8.B2.9D.E8.8C.B2.E6.9B.B2.E7.B7.9A">维基</a>上查看其具体的定义。二次贝塞尔曲线需要两个点来确定，分别是终点和控制点。iOS 中的<code>UIbezierPath</code>类提供了<code>addQuadCurveToPoint: controlPoint:</code>方法来绘制一条二次贝塞尔曲线。</p><p>由于相对定位是相对于前一 path 的终点来说，而二次贝塞尔曲线因为有两个点需要在本次绘制的时候确定，因此，绘制的时候需要同时计算控制点和终点的坐标。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Q命令格式如下：&quot;Q 95 10 180 80&quot;，其中(95, 10)是控制点坐标，(180, 80)是终点坐标</span></span><br><span class="line"><span class="built_in">CGPoint</span> c = <span class="built_in">CGPointMake</span>(<span class="number">95</span>, <span class="number">10</span>); <span class="comment">// 控制点</span></span><br><span class="line"><span class="built_in">CGPoint</span> p = <span class="built_in">CGPointMake</span>(<span class="number">180</span>, <span class="number">80</span>); <span class="comment">// 终点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (relative) &#123;</span><br><span class="line">    c = <span class="built_in">CGPointMake</span>(lastPoint.x + c.x, lastPoint.y + c.y);</span><br><span class="line">    p = <span class="built_in">CGPointMake</span>(lastPoint.x + p.x, lastPoint.y + p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.path addQuadCurveToPoint:p controlPoint:c];</span><br><span class="line"></span><br><span class="line">lastPoint = p;</span><br><span class="line"><span class="comment">// 因为下文中的 T 命令，所以需要保存二次贝塞尔曲线的控制点</span></span><br><span class="line">preQCtrl = c;</span><br></pre></td></tr></table></figure><h4 id="T命令"><a href="#T命令" class="headerlink" title="T命令"></a>T命令</h4><p>T 命令实际上也是绘制一条二次贝塞尔曲线，与 Q 命令不同的是，T 命令不需要指定控制点坐标，只需要一个终点坐标。控制点坐标是前一段 path 的控制点相对于终点的对称点。如下图，蓝色直线与红色直线的交点为前一 path 的终点 p，红色直线向上延长的终点为前一 path 的控制点 c1 ，蓝色直线向下延长的终点为当前绘制曲线的控制点 c2 ，c1 和 c2 相对于 p 对称。因此 c2 的坐标计算公式为 <code>c2.x = p.x + (p.x - c1.x)，c2.y = p.y + (p.y - c1.y)</code>。<br><img src="https://developer.mozilla.org/@api/deki/files/364/=Shortcut_Quadratic_Bezier.png"><br><em><strong>需要注意的是，T 命令前面必须也是一条二次贝塞尔曲线，即前一个命令必须是 Q 命令或者 T 命令。如果 T 命令单独出现的话，将会画出一条直线。</strong></em></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T命令格式如下：&quot;T95 10&quot;，(95, 10)是二次贝塞尔曲线的终点</span></span><br><span class="line"><span class="built_in">CGPoint</span> p = <span class="built_in">CGPointMake</span>(<span class="number">95</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">CGPoint</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (relative) &#123;</span><br><span class="line">    p = <span class="built_in">CGPointMake</span>(lastPoint.x + p.x, lastPoint.y + p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 T 命令前不是二次贝塞尔曲线，将会画出一条直线，也就是说控制点在终点和起点的连线上</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CGPointEqualToPoint</span>(preQCtrl, <span class="built_in">CGPointZero</span>)) &#123;</span><br><span class="line">    c = p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = <span class="built_in">CGPointMake</span>(lastPoint.x + (lastPoint.x - preQCtrl.x), lastPoint.y + (lastPoint.y - preQCtrl.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.path addQuadCurveToPoint:p controlPoint:c];</span><br><span class="line"></span><br><span class="line">lastPoint = p;</span><br><span class="line">preQCtrl = c;</span><br></pre></td></tr></table></figure><h4 id="C命令"><a href="#C命令" class="headerlink" title="C命令"></a>C命令</h4><p>C 命令用来创建三次贝塞尔曲线。三次贝塞尔曲线需要三个点来确定，分别是终点和两个控制点。iOS 中的<code>UIbezierPath</code>类同样提供了<code>addCurveToPoint: controlPoint1: controlPoint2:</code>方法来绘制一条三次贝塞尔曲线。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C命令格式如下：&quot;C 20 20, 40 20, 50 10&quot;</span></span><br><span class="line"><span class="comment">// 控制点1：(20, 20)，控制点2：(40, 20)，终点：(50, 10)</span></span><br><span class="line"><span class="built_in">CGPoint</span> c1 = <span class="built_in">CGPointMake</span>(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">CGPoint</span> c2 = <span class="built_in">CGPointMake</span>(<span class="number">40</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">CGPoint</span> p  = <span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同Q命令一样，相对定位情况下需要计算所有控制点和终点的坐标</span></span><br><span class="line"><span class="keyword">if</span> (relative) &#123;</span><br><span class="line">  c1 = <span class="built_in">CGPointMake</span>(lastPoint.x + c1.x, lastPoint.y + c1.y);</span><br><span class="line">  c2 = <span class="built_in">CGPointMake</span>(lastPoint.x + c2.x, lastPoint.y + c2.y);</span><br><span class="line">  p = <span class="built_in">CGPointMake</span>(lastPoint.x + p.x, lastPoint.y + p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.path addCurveToPoint:p controlPoint1:c1 controlPoint2:c2];</span><br><span class="line">lastPoint = p;</span><br><span class="line"><span class="comment">// 因为下文中的 S 命令，所以需要保存三次贝塞尔曲线的第二个控制点</span></span><br><span class="line">preCCtrl = c2;</span><br></pre></td></tr></table></figure><h4 id="S命令"><a href="#S命令" class="headerlink" title="S命令"></a>S命令</h4><p>S 命令可以用来创建与之前 C 或者 S 命令一样的三次贝塞尔曲线。S 命令的第一个控制点是前一条三次贝塞尔曲线的第二个控制点相对于终点的对称点。如下图，蓝色和红色线段的交点为上一线段的终点 p，红色线段向上延长的终点为第一条线段的第二个控制点 c12，蓝色线段向下延长的终点为第二条线段的第一个控制点 c21，c12 和 c21 相对于 p 对称。因此 c21 的坐标计算公式为：<code>c21.x = p.x + (p.x - c12.x), c21.y = p.y + (p.y - c12.y) </code>。</p><p><img src="https://developer.mozilla.org/@api/deki/files/363/=ShortCut_Cubic_Bezier.png"><br><em><strong>如果 S 命令单独使用，那么它的两个控制点将会使用同一个坐标。</strong></em></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S命令的格式如下：&quot;S 150 150, 180 80&quot;</span></span><br><span class="line"><span class="comment">// 第二个控制点：(150, 150)，终点：(180, 80)</span></span><br><span class="line"><span class="built_in">CGPoint</span> c1;</span><br><span class="line"><span class="built_in">CGPoint</span> c2 = <span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line"><span class="built_in">CGPoint</span> p = <span class="built_in">CGPointMake</span>(<span class="number">180</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (relative) &#123;</span><br><span class="line">  c2 = <span class="built_in">CGPointMake</span>(lastPoint.x + c2.x, lastPoint.y + c2.y);</span><br><span class="line">  p = <span class="built_in">CGPointMake</span>(lastPoint.x + p.x, lastPoint.y + p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果前一个命令不是C命令或者S命令，则第一个控制点与第二个控制点坐标相同</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CGPointEqualToPoint</span>(preCCtrl, <span class="built_in">CGPointZero</span>)) &#123;</span><br><span class="line">  c1 = c2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  c1 = <span class="built_in">CGPointMake</span>(lastPoint.x + (lastPoint.x - preCCtrl.x), lastPoint.y + (lastPoint.y - preCCtrl.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.path addCurveToPoint:p controlPoint1:c1 controlPoint2:c2];</span><br><span class="line"></span><br><span class="line">lastPoint = p;</span><br><span class="line">preCCtrl = c2;</span><br></pre></td></tr></table></figure><h4 id="A命令"><a href="#A命令" class="headerlink" title="A命令"></a>A命令</h4><p>暂略。</p><h4 id="Z命令"><a href="#Z命令" class="headerlink" title="Z命令"></a>Z命令</h4><p>Z命令代表封闭 path。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.path close];</span><br></pre></td></tr></table></figure><h4 id="查漏"><a href="#查漏" class="headerlink" title="查漏"></a>查漏</h4><p>因为二次贝塞尔曲线和三次贝塞尔曲线都需要记录一个控制点，并且二次和三次贝塞尔曲线的记录不一样，所以在执行其它命令的时候，需要将记录清空（设置成CGPointZero）以免 T 和 S 命令误以为前一 path 是二次或者三次贝塞尔曲线。<br>因此在执行命令的<code>executeCommand:(const char *)command Numbers:(NSArray&lt;NSNumber *&gt; *)nums</code>方法开头部分添加如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果命令不是 Q 和 T，需要将记录二次贝塞尔曲线控制点的属性 preQCtrl 设为 CGPointZero</span></span><br><span class="line"><span class="comment">// 因此在非 Q 和 T 命令的情况下，便于单独的 T 命令进行判断</span></span><br><span class="line"><span class="built_in">NSString</span> *q_excluded = <span class="string">@&quot;MmLlAaCcSsHhVvZz&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ([q_excluded containsString:[<span class="built_in">NSString</span> stringWithUTF8String:command]]) &#123;</span><br><span class="line">    preQCtrl = <span class="built_in">CGPointZero</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果命令不是 C 和 S，需要将记录三次贝塞尔曲线第二个控制点的属性 preCCtrl 设为 CGPointZero</span></span><br><span class="line"><span class="comment">// 因此在非 C 和 S 命令的情况下，便于单独的 S 命令进行判断</span></span><br><span class="line"><span class="built_in">NSString</span> *c_excluded = <span class="string">@&quot;MmLlAaQqTtHhVvZz&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ([c_excluded containsString:[<span class="built_in">NSString</span> stringWithUTF8String:command]]) &#123;</span><br><span class="line">    preCCtrl = <span class="built_in">CGPointZero</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文只是简单介绍了 SVG 中 path 的基础绘制，其中主要的内容在于：</p><ol><li><p>将命令和参数正确的解析出来；</p></li><li><p>弄清楚相对坐标和绝对坐标情况下的 path 的点所应处的位置；</p></li><li><p>另外就是弄清楚T和S命令的控制点是怎么确定的。</p></li></ol><p>其它方面的东西都是很容易的。</p><p>详细代码请关注GitHub：<a href="https://github.com/Zeacone/SVGlib">Zeacone</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中绘制SVG（一）：SVG文件的解析</title>
      <link href="/2017/08/24/iOS%E4%B8%AD%E7%BB%98%E5%88%B6SVG%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASVG%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/08/24/iOS%E4%B8%AD%E7%BB%98%E5%88%B6SVG%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASVG%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-SVG-的实质"><a href="#0x01-SVG-的实质" class="headerlink" title="0x01 SVG 的实质"></a>0x01 SVG 的实质</h3><p>SVG实质上是一个XML格式的文本文件，可以同普通的XML文件一样通过一些XML解析库来进行解析。因此绘制SVG的过程实际上是先解析XML文件，然后根据解析出来的命令在屏幕上绘制出来。</p><p>SVG的命令常见的有形状、transform、文字、渐变和滤镜。在本系列的文章中，只讨论基本的形状绘制，不涉及文字、渐变和滤镜的部分。</p><span id="more"></span><p>而形状部分主要包括7个类型，分别是：</p><ul><li>path</li><li>line</li><li>circle</li><li>rect</li><li>ellipse</li><li>polyline</li><li>polygon</li></ul><p>transform主要包括：</p><ul><li>move</li><li>rotate</li><li>scale</li></ul><p>而本文章主要就是讨论上述所说的命令本身和其拥有属性的解析。</p><h3 id="0x02-SVG-元素的解析"><a href="#0x02-SVG-元素的解析" class="headerlink" title="0x02 SVG 元素的解析"></a>0x02 SVG 元素的解析</h3><p>第一步，先获取SVG的路径，使用iOS系统自带的XML解析工具进行解析。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:fileName];</span><br><span class="line"><span class="built_in">NSXMLParser</span> *parser = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:data];</span><br><span class="line">parser.delegate = <span class="keyword">self</span>;</span><br><span class="line">[parser parse];</span><br></pre></td></tr></table></figure><p>第二步，实现XML解析的代理方法，通过<code>elementName</code>来创建对应形状的类。因为解析出来的形状拥有许多相同的属性，因此新建一个基类<code>SVGElement</code>，其它所有的形状都会继承此基类。基类包含的属性和方法如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SVGElement</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAttribute:(<span class="built_in">NSDictionary</span> *)attr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="comment">// 标识一个元素的id</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *identifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *className;</span><br><span class="line"><span class="comment">// 该元素的transform属性字符串</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *tranform;</span><br><span class="line"><span class="comment">// 该元素所属的分组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *group;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来绘制该元素的贝塞尔曲线</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIBezierPath</span> *path;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  绘制该元素时的stroke color和fill color</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *strokeColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *fillColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  标记此元素被绘制到屏幕上之后是否能够响应点击事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> selectable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后在XML解析的代理方法中实现对应形状的解析，通过<code>elementName</code>拼接成对应的类名，然后使用<code>NSClassFromString</code>生成对应的类。另外新建一个<code>elements</code>的数组用来存储所有解析出来的元素。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didStartElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName attributes:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="built_in">NSString</span> *&gt; *)attributeDict &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *names = @[<span class="string">@&quot;path&quot;</span>, <span class="string">@&quot;rect&quot;</span>, <span class="string">@&quot;circle&quot;</span>, <span class="string">@&quot;ellipse&quot;</span>, <span class="string">@&quot;line&quot;</span>, <span class="string">@&quot;polyline&quot;</span>, <span class="string">@&quot;polygon&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取SVG的共有属性，比如SVG的size等等</span></span><br><span class="line">    <span class="keyword">if</span> ([elementName isEqualToString:<span class="string">@&quot;svg&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 获取公有属性 like viewbox</span></span><br><span class="line">        <span class="built_in">CGFloat</span> width = attributeDict[<span class="string">@&quot;width&quot;</span>].doubleValue;</span><br><span class="line">        <span class="built_in">CGFloat</span> height = attributeDict[<span class="string">@&quot;height&quot;</span>].doubleValue;</span><br><span class="line">        <span class="keyword">self</span>.svgSize = <span class="built_in">CGSizeMake</span>(width, height);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([elementName isEqualToString:<span class="string">@&quot;g&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// group</span></span><br><span class="line">        <span class="keyword">self</span>.transform = [attributeDict objectForKey:<span class="string">@&quot;transform&quot;</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([names containsObject:elementName]) &#123;</span><br><span class="line">    <span class="comment">// 根据元素的name生成对应的类，比如SVGCircle、SVGPath等</span></span><br><span class="line">        <span class="built_in">NSString</span> *className = [<span class="string">@&quot;SVG&quot;</span> stringByAppendingString:[elementName capitalizedString]];</span><br><span class="line">        </span><br><span class="line">        Class myClass = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">        </span><br><span class="line">        SVGElement *element = [((SVGElement *)[myClass alloc]) initWithAttribute:attributeDict];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (element) &#123;</span><br><span class="line">        <span class="comment">// 如果元素存在，获取对应的属性字符串</span></span><br><span class="line">            <span class="keyword">if</span> (!element.tranform &amp;&amp; <span class="keyword">self</span>.transform) &#123;</span><br><span class="line">                element.tranform = <span class="keyword">self</span>.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将解析出来的元素添加到数组中，便于解析完成之后的绘制</span></span><br><span class="line">            [<span class="keyword">self</span>.elements addObject:element];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代理方法中，通过初始化方法<code>initWithAttribute:</code>已经将<code>attributeDict</code>属性拿到，会在初始化方法里面进行解析拆分出各个详细的属性，此处不进行详细的介绍，具体可看文章末尾所附上的GitHub链接。</p><h3 id="0x03-SVG-transform的解析"><a href="#0x03-SVG-transform的解析" class="headerlink" title="0x03 SVG transform的解析"></a>0x03 SVG transform的解析</h3><p>一个常见的transform属性字符串如下所示：<br>transform&#x3D;”translate(398.000000, 1925.000000) rotate(90.000000) translate(-398.000000, -1925.000000) translate(-1527.000000, 1527.000000)”</p><p>举例所示的transform包含了translate和rotate，另外常见的还有scale。此处要做的便是将transform字符串解析成iOS能识别的<code>CGAffineTransform</code>类型。</p><p>根据<code>translate</code>、<code>scale</code>和<code>rotate</code>这3个关键字利用正则表达式将transform字符串拆分成一个包含<code>NSTextCheckingResult</code>对象的数组，此时的<code>NSTextCheckingResult</code>对象实际上就是一个命令加上对应的参数，如<code>translate(398.000000, 1925.000000)</code>，然后通过<code>NSScanner</code>忽略掉某些特殊字符，将后面的参数扫描出来，就满足了构成一个<code>CGAffineTransform</code>对象的条件。按照transform字符串的顺序依次解析就构成了最终的<code>CGAffineTransform</code>。<br>需要注意的是，SVG中<code>rotate</code>使用的是角度，在iOS中需要转换成弧度再进行使用。</p><p>详细的转换代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">CGAffineTransform</span>)transformFromString:(<span class="built_in">NSString</span> *)transformString &#123;</span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSRegularExpression</span> *regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:<span class="string">@&quot;translate|scale|rotate&quot;</span> options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSTextCheckingResult</span> *&gt; *checkResults = [regex matchesInString:transformString options:<span class="number">0</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [transformString length])];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSScanner</span> *scanner = [<span class="built_in">NSScanner</span> scannerWithString:transformString];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableCharacterSet</span> *skippedCharacterSet = [[<span class="built_in">NSMutableCharacterSet</span> alloc] init];</span><br><span class="line">    [skippedCharacterSet formUnionWithCharacterSet:[<span class="built_in">NSCharacterSet</span> letterCharacterSet]];</span><br><span class="line">    [skippedCharacterSet formUnionWithCharacterSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@&quot;,() &quot;</span>]];</span><br><span class="line">    </span><br><span class="line">    scanner.charactersToBeSkipped = skippedCharacterSet;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *result <span class="keyword">in</span> checkResults) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([[transformString substringWithRange:result.range] isEqualToString:<span class="string">@&quot;translate&quot;</span>]) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> valueX;</span><br><span class="line">            <span class="built_in">CGFloat</span> valueY;</span><br><span class="line">            [scanner scanDouble:&amp;valueX];</span><br><span class="line">            [scanner scanDouble:&amp;valueY];</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, valueX, valueY);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([[transformString substringWithRange:result.range] isEqualToString:<span class="string">@&quot;rotate&quot;</span>]) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> angle;</span><br><span class="line">            [scanner scanDouble:&amp;angle];</span><br><span class="line">            </span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, [<span class="keyword">self</span>.class radianFromAngle:angle]);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([[transformString substringWithRange:result.range] isEqualToString:<span class="string">@&quot;scale&quot;</span>]) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGFloat</span> scale;</span><br><span class="line">            [scanner scanDouble:&amp;scale];</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformScale</span>(transform, scale, scale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> transform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)radianFromAngle:(<span class="built_in">CGFloat</span>)angle &#123;</span><br><span class="line">    <span class="keyword">return</span> angle / <span class="number">180.0</span> * M_PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x04-SVG-Path命令的解析"><a href="#0x04-SVG-Path命令的解析" class="headerlink" title="0x04 SVG Path命令的解析"></a>0x04 SVG Path命令的解析</h3><p>Path命令的解析由于和path的绘制关联紧密，因此会在path的绘制章节中一起进行讲解。</p><p>关于SVG的解析绘制所有源码包括demo可在GitHub进行查看：<a href="https://github.com/Zeacone/SVGlib">SVGlib</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中实现深拷贝</title>
      <link href="/2017/05/24/%E5%9C%A8Swift%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2017/05/24/%E5%9C%A8Swift%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="关于数组拷贝的例子"><a href="#关于数组拷贝的例子" class="headerlink" title="关于数组拷贝的例子"></a>关于数组拷贝的例子</h3><p>首先，先看一个例子。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> teachers <span class="operator">=</span> [<span class="type">Teacher</span>(name: <span class="string">&quot;Alex&quot;</span>, age: <span class="number">32</span>)]</span><br><span class="line"><span class="keyword">var</span> students <span class="operator">=</span> [<span class="type">Student</span>(name: <span class="string">&quot;Bob&quot;</span>, age: <span class="number">18</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> teachersCopy <span class="operator">=</span> teachers</span><br><span class="line"><span class="keyword">var</span> studentsCopy <span class="operator">=</span> students</span><br><span class="line"></span><br><span class="line">teachersCopy[<span class="number">0</span>].name <span class="operator">=</span> <span class="string">&quot;AlexCopy&quot;</span></span><br><span class="line">studentsCopy[<span class="number">0</span>].name <span class="operator">=</span> <span class="string">&quot;BobCopy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(teachers[<span class="number">0</span>].name, teachersCopy[<span class="number">0</span>].name) <span class="comment">// &quot;Alex AlexCopy&quot;</span></span><br><span class="line"><span class="built_in">print</span>(students[<span class="number">0</span>].name, studentsCopy[<span class="number">0</span>].name) <span class="comment">// &quot;BobCopy BobCopy&quot;</span></span><br></pre></td></tr></table></figure><p>为什么会出现上述这种情况呢？根据 Apple 的文档来看：</p><blockquote><p>Each array has an independent value that includes the values of all of its elements. For simple types such as integers and other structures, this means that when you change a value in one array, the value of that element does not change in any copies of the array.</p></blockquote><p>简单翻译一下的意思就是，每个数组包括它包含的所有元素都有其独立的值。对于简单类型例如整型和其它结构来说，这意味着当你改变一个数组中的值时，该元素的值在数组的其它副本中的值并不会随之改变。</p><blockquote><p>If the elements in an array are instances of a class, the semantics are the same, though they might appear different at first. In this case, the values stored in the array are references to objects that live outside the array. If you change a reference to an object in one array, only that array has a reference to the new object. However, if two arrays contain references to the same object, you can observe changes to that object’s properties from both arrays. </p></blockquote><p>但是，如果数组中的元素是类的实例的话，在这种情况下，数组中存储的只是存在于数组外部的对象的引用。如果在一个数组中更改对对象的引用，则只有该数组具有对新对象的引用。 但是，如果两个数组包含对同一对象的引用，则可以从两个数组中观察到对该对象属性的更改。</p><p>回到我们的例子，因为 <code>Teacher</code>是一个结构体，属于简单数据类型，当存放它的数组被 copy 的时候，同时复制了数组中所有元素的值。所以，更改<code>teachersCopy</code>中的元素的时候原数组不受影响。</p><p>而<code>Student</code>是一个<code>class</code>，当存放<code>Student</code>的数组被复制的时候，复制的其实是对象的引用，因此对<code>studentsCopy</code>中的元素更改值的时候，两个数组中的元素都被更改。</p><h3 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h3><p>那么如何实现包含类实例的深拷贝呢？众所周知，在<code>Objective-C</code>中自定义类要实现copy需要遵循<code>NSCopying</code>协议。在 Swift 中也是一样的做法。</p><p>首先，定义一个<code>Coping</code>协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Copying</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">init</span>(<span class="params">original</span>: <span class="keyword">Self</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Copying</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">copy</span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">Self</span>.<span class="keyword">init</span>(original: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，让我们的自定义类遵循这个协议，并实现相应的方法。同时，在 copy 数组的时候也要改变方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_">Copying</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">original</span>: <span class="type">Student</span>) &#123;</span><br><span class="line">        name <span class="operator">=</span> original.name</span><br><span class="line">        age <span class="operator">=</span> original.age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> studentsCopy <span class="operator">=</span> [<span class="type">Student</span>]()</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> students &#123;</span><br><span class="line">    <span class="keyword">let</span> copiedStudent <span class="operator">=</span> student.copy()</span><br><span class="line">    studentsCopy.append(copiedStudent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，再修改<code>studentsCopy</code>中的内容，<code>students</code>就不会再随之改变了，数组的深拷贝也就实现了。</p><p>当然，还有更精简一些的写法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Copying</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">copy</span>() -&gt; <span class="type">Array</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> copiedArray <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Element</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            copiedArray.append(element.copy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copiedArray</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> studentsCopy <span class="operator">=</span> students.copy()</span><br></pre></td></tr></table></figure><p>That’s done.</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动画的暂停与恢复原理</title>
      <link href="/2017/04/14/%E5%8A%A8%E7%94%BB%E7%9A%84%E6%9A%82%E5%81%9C%E4%B8%8E%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86/"/>
      <url>/2017/04/14/%E5%8A%A8%E7%94%BB%E7%9A%84%E6%9A%82%E5%81%9C%E4%B8%8E%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>之前在做一个语音播放功能的时候，封面随着播放而旋转，而封面的旋转动画会随着音频的播放状态而改变。那么怎么暂停和恢复这个旋转动画呢？对于面向搜索引擎编程的程序员来说，立马在谷歌输入“CAAnimation pause”字样立刻就找到了如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">pause</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> pausedTime <span class="operator">=</span> layer.convertTime(<span class="type">CACurrentMediaTime</span>(), from: <span class="literal">nil</span>)</span><br><span class="line">    layer.speed <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    layer.timeOffset <span class="operator">=</span> pausedTime</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">resume</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> pausedTime <span class="operator">=</span> layer.timeOffset</span><br><span class="line">    layer.speed <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    layer.timeOffset <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    layer.beginTime <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> timeSincePause <span class="operator">=</span> layer.convertTime(<span class="type">CACurrentMediaTime</span>(), from: <span class="literal">nil</span>) <span class="operator">-</span> pausedTime</span><br><span class="line">    layer.beginTime <span class="operator">=</span> timeSincePause</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMD+R</code> 跑一下，OK，完美运行。</p><p>解决了问题之后，那么为什么这段代码能够暂停和恢复动画呢？<code>CACurrentMediaTime()</code>、<code>beginTime</code>、<code>timeOffset</code> 又是些什么东西，起什么作用呢？</p><p>我们一个一个来看。</p><p>根据文档，<code>CACurrentMediaTime()</code> 返回的是 <code>CoreAnimation</code> 的绝对时间，换一种说法就是其返回的是手机自开机以后所经过的秒数。其时间轴的参考系是手机的运行时间而不是现实世界的真实时间。</p><p><code>beginTime</code> 指定了 layer 相对于其父视图的开始时间，默认为0。<br>文档说得比较抽象，还是要实践出真知。来看下面一段代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>()</span><br><span class="line">view.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">10</span>, y: <span class="number">10</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">view.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.red</span><br><span class="line">view.layer.beginTime <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">addSubview(view)</span><br></pre></td></tr></table></figure><p>运行一下，可以看到最开始的时候，我们添加的视图是不会显示的，在等待 2 秒之后才会出现。如果把代码改一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">    view.layer.beginTime <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时发现视图是一开始就绘制出来了，之后也没有消失。<br>再把代码改一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">    view.layer.beginTime <span class="operator">=</span> <span class="type">CACurrentMediaTime</span>() <span class="operator">+</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，可以观察到，视图在一开始被绘制了出来，但是在 5 秒之后视图消失，2 秒之后视图再次出现。</p><p>beginTime 实际上是设置的一个时间点，它标记了本对象相对于父对象的启动时间。假如父对象的时间基点是100，第一个例子中就是相对于父对象 2 秒后启动，也就是102秒的时候启动。第二个例子同样是102秒的时候启动，但是此时父对象已经到了105了，时间不可能倒流，所以这样设置没有效果。第三个例子，时间来到105秒，此时设置的启动时间是当前的时间点再加上2秒，也就是107秒的时候启动，所以能能正常运行。</p><blockquote><p>解释有问题<br>第三个例子中的 beginTime 如果是相对于父对象的话，应该是107 秒后启动，为什么也会是 2 秒后启动呢？</p></blockquote><p><code>timeOffset</code> 的概念理解起来就容易得多了。它的作用就是将 layer 设置成某一个时刻的固定状态。比如说一个 10 秒的进度动画，在第 2.5 秒的时候是绘制了 90 度，那么将 <code>timeOffset</code> 设置为 2.5，那么 layer 就会呈现出 90 度的样子。<br>需要注意的是，<code>timeOffset</code> 的时间是layer 的本地时间，写代码的过程中要先计算出本地时间再进行设置。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝塞尔曲线动画问题（Swift修订版）</title>
      <link href="/2016/11/02/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%8A%A8%E7%94%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2016/11/02/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%8A%A8%E7%94%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#0x00-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E4%B8%8E-core-animation">0x00 贝塞尔曲线与 Core Animation</a></li><li><a href="#0x01-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">0x01 存在的问题</a></li><li><a href="#0x02-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98">0x02 解决问题</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E6%AE%B5%E5%92%8C%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84">创建具有相同数量的线段和点的路径</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB">创建自定义的路径动画</a></li></ul></li></ul><!-- /TOC --><h3 id="0x00-贝塞尔曲线与-Core-Animation"><a href="#0x00-贝塞尔曲线与-Core-Animation" class="headerlink" title="0x00 贝塞尔曲线与 Core Animation"></a>0x00 贝塞尔曲线与 Core Animation</h3><p>众所周知， 在 <code>iOS</code> ，通过Core Animation能够制作出丰富的动画效果，比如缩放，颜色渐变，位移。Core Animation的作用对象是 CALayer，而这其中最重要的组合就是CAShapeLayer和UIBezierPath了。<br>通过对 CAShapeLayer 的 path 重新赋值，可以得到更多灵活可自定义的动画效果。</p><h3 id="0x01-存在的问题"><a href="#0x01-存在的问题" class="headerlink" title="0x01 存在的问题"></a>0x01 存在的问题</h3><p>但是，如果不能正确地使用 path 来制作动画可能会得到意料之外的效果。比如我想使一个圆角矩形，变化成为一个圆形。如果使用如下的代码，你会发现实际的动画效果并不符合预期，而是会经历一个奇怪的形状变换。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fromPath <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: .<span class="keyword">init</span>(x: <span class="number">100</span>, y: <span class="number">300</span>, width: <span class="number">120</span>, height: <span class="number">40</span>), cornerRadius: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> toPath <span class="operator">=</span> <span class="type">UIBezierPath</span>(arcCenter: .<span class="keyword">init</span>(x: <span class="number">160</span>, y: <span class="number">320</span>), radius: <span class="number">20</span>, startAngle: <span class="operator">-</span>.pi<span class="operator">/</span><span class="number">2</span>, endAngle: .pi<span class="operator">*</span><span class="number">3</span><span class="operator">/</span><span class="number">2</span>, clockwise: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anim <span class="operator">=</span> <span class="type">CABasicAnimation</span>(keyPath: <span class="string">&quot;path&quot;</span>)</span><br><span class="line">anim.duration <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">anim.fromValue <span class="operator">=</span> fromPath.cgPath</span><br><span class="line">anim.toValue <span class="operator">=</span> toPath.cgPath</span><br><span class="line">anim.isRemovedOnCompletion <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">anim.fillMode <span class="operator">=</span> .forwards</span><br><span class="line">shape.add(anim, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>那么，造成这种问题的原因是什么呢？翻阅 Apple 官方文档可以找到<a href="https://developer.apple.com/documentation/quartzcore/cashapelayer/1521904-path">原因</a></p><blockquote><p>If the two paths have a different number of control points or segments the results are undefined. If the path extends outside the layer bounds it will not automatically be clipped to the layer, only if the normal layer masking rules cause that.</p></blockquote><p>这句话的意思就是如果两条路径拥有不同数量的控制点或者险段，那么最终的动画结果是不可预料的。因此直接使用不同的路径来生成动画是不可控的，除非前后的路径是一样的。</p><h3 id="0x02-解决问题"><a href="#0x02-解决问题" class="headerlink" title="0x02 解决问题"></a>0x02 解决问题</h3><p>发现了问题，接下来就是如何解决问题，这里提供两种方法。</p><h4 id="创建具有相同数量的线段和点的路径"><a href="#创建具有相同数量的线段和点的路径" class="headerlink" title="创建具有相同数量的线段和点的路径"></a>创建具有相同数量的线段和点的路径</h4><p>简单来说，第一种方法就是要保证动画足够简单，如果过于复杂则会消耗太多的时间与精力，得不偿失。<br>比如说，要使一个圆角矩形变换为一个圆，如果要使用路径来实现动画的话，只需要修改注释1处的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fromPath <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: .<span class="keyword">init</span>(x: <span class="number">100</span>, y: <span class="number">300</span>, width: <span class="number">120</span>, height: <span class="number">40</span>), cornerRadius: <span class="number">20</span>)</span><br><span class="line"><span class="comment">// let toPath = UIBezierPath(arcCenter: .init(x: 160, y: 320), radius: 20, startAngle: -.pi/2, endAngle: .pi*3/2, clockwise: true)</span></span><br><span class="line"><span class="keyword">let</span> toPath <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: .<span class="keyword">init</span>(x: <span class="number">140</span>, y: <span class="number">300</span>, width: <span class="number">40</span>, height: <span class="number">40</span>), cornerRadius: <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anim <span class="operator">=</span> <span class="type">CABasicAnimation</span>(keyPath: <span class="string">&quot;path&quot;</span>)</span><br><span class="line">anim.duration <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">anim.fromValue <span class="operator">=</span> fromPath.cgPath</span><br><span class="line">anim.toValue <span class="operator">=</span> toPath.cgPath</span><br><span class="line">anim.isRemovedOnCompletion <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">anim.fillMode <span class="operator">=</span> .forwards</span><br><span class="line">shape.add(anim, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这样我们的圆角矩形就能很流畅地变化成为一个圆形了。  </p><p>但是这种方法也并非每次都奏效，比如从一个1&#x2F;4圆变化为一个半圆。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fromPath <span class="operator">=</span> <span class="type">UIBezierPath</span>(arcCenter: view.center, radius: <span class="number">100</span>, startAngle: <span class="operator">-</span>.pi<span class="operator">/</span><span class="number">2</span>, endAngle: <span class="number">0</span>, clockwise: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> toPath <span class="operator">=</span> <span class="type">UIBezierPath</span>(arcCenter: view.center, radius: <span class="number">100</span>, startAngle: <span class="operator">-</span>.pi<span class="operator">/</span><span class="number">2</span>, endAngle: .pi<span class="operator">/</span><span class="number">2</span>, clockwise: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>在 <code>playground</code> 中的运行结果如下：</p><p><img src="https://i.loli.net/2021/11/30/wza9SIU8fVOMncj.gif" alt="Nov-30-2021 22-40-55.gif"></p><p>可见，这种方法并不是绝对保险的。这就要使用到第二种方法了。</p><h4 id="创建自定义的路径动画"><a href="#创建自定义的路径动画" class="headerlink" title="创建自定义的路径动画"></a>创建自定义的路径动画</h4><p>这种方法其实就是将动画过程中的每一帧都手动绘制出来。由于整个动画的每一帧都是我们自己来绘制，因此就不会有动画过程不可控的情况发生。那么如何绘制动画过程中的每一帧呢？这就要用到自定义动画属性了。</p><p>我们首先创建一个自定义 layer，定义一个变量，这个变量可以随便取名，但是它一定是要和动画进度相关联的，比如说一个进度动画，我们需要的是从 0 到 100 的这么一个过程，那么我们定义的这个变量就得是 0 到 100 这个区间里的值。如下面例子中的 <code>progress</code>。<br>定义好变量之后，然后重写 <code>needsDisplay(forKey:)</code> 这个方法，其中默认的返回值为 false，将我们所需要改变的动画属性返回 true。此处的自定义 key 就是所定义的变量的名称。</p><p>最后就是在draw(in:)方法中绘制动画的每个阶段的图像，这样我们的自定义 layer 就算完成了。<br>⚠️注意，此处绘制需要根据 progress 的值来进行，以突出每一帧的变化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SectorLayer</span>: <span class="title class_">CALayer</span> &#123;</span><br><span class="line">    <span class="keyword">@NSManaged</span> <span class="keyword">var</span> progress: <span class="type">CGFloat</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">needsDisplay</span>(<span class="title class_">forKey</span> <span class="title class_">key</span>: <span class="title class_">String</span>) -&gt; <span class="title class_">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> key <span class="operator">==</span> <span class="string">&quot;progress&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.needsDisplay(forKey: key)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">draw</span>(<span class="params">in</span> <span class="params">ctx</span>: <span class="type">CGContext</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> circleCenter <span class="operator">=</span> <span class="type">CGPoint</span>(</span><br><span class="line">            x: bounds.midX,</span><br><span class="line">            y: bounds.midX)</span><br><span class="line">        ctx.setFillColor(<span class="type">UIColor</span>.orange.cgColor)</span><br><span class="line">        ctx.move(to: circleCenter)</span><br><span class="line">        ctx.addArc(</span><br><span class="line">            center: circleCenter,</span><br><span class="line">            radius: bounds.midX,</span><br><span class="line">            startAngle: <span class="number">0</span>,</span><br><span class="line">            endAngle: .pi <span class="operator">*</span> <span class="number">2</span> <span class="operator">*</span> progress,</span><br><span class="line">            clockwise: <span class="literal">true</span>)</span><br><span class="line">        ctx.closePath()</span><br><span class="line">        ctx.drawPath(using: .fill)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何让自定义 layer 的动画生效呢？也很简单，只需要加上一个常规的 <code>CABasicAnimation</code>，将 keyPath 设置为我们定义的变量名字，就可以正常运行了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">startAnimation</span>(<span class="params">for</span> <span class="params">layer</span>: <span class="type">SectorLayer</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> anim <span class="operator">=</span> <span class="type">CABasicAnimation</span>(keyPath: <span class="string">&quot;progress&quot;</span>)</span><br><span class="line">    anim.duration <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    anim.fromValue <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    anim.toValue <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    layer.add(anim, forKey: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是自定义动画的结果。<br><img src="https://i.loli.net/2021/11/30/2dfKEhzITQZNbDj.gif" alt="Nov-30-2021 22-40-43.gif"></p><blockquote><p><strong>⚠️重要</strong><br>当动画 isRemovedOnCompletion 设置为 false，fillMode 设置为 forwards 时，在动画结束时，要手动将动画移除，否则 layer 将会一直进行重复绘制，造成无效的资源占用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoreAnimation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Notification 的使用</title>
      <link href="/2016/10/11/%E5%85%B3%E4%BA%8E%20Notification%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/10/11/%E5%85%B3%E4%BA%8E%20Notification%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>一直以来，对于 <code>Notification</code> 的使用都理解得不是特别透彻，<code>dealloc</code> 中要不要移除 <code>observer</code>，<code>block</code> 中要不要加 <code>weak</code>，一直都是能加就加，根本未考虑过为什么要加或者说为什么可以不加。这篇记录就将这些问题一次性地弄个明白。</p><h3 id="0x01-removeObserver"><a href="#0x01-removeObserver" class="headerlink" title="0x01 removeObserver?"></a>0x01 removeObserver?</h3><p>Apple 的官方文档说明中，在 iOS 9.0，macOS 10.11 及以后的系统版本中，使用 <code>addObserver:selector:name:object:</code> 方式添加的通知可以不再手动移除通知。而使用 <code> addObserverForName:object:queue:usingBlock:</code> 方式添加的通知在之前是需要手动移除的，而在新版本中则没有特意指明是否需要移除。</p><p>那么我们就用代码来实际测试一下。</p><p>首先，我们为 <code>NotificationCenter</code> 添加一个扩展方法，用自定义的方法对 <code>removeObserver</code> 进行交换，并在自定义方法中输出我们想要的信息。这样就能够在退出界面时在控制台方便地看到 <code>Notification</code> 到底有没有移除 <code>observer</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">NotificationCenter</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">swizzling</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> selector <span class="operator">=</span> <span class="keyword">#selector</span>(<span class="type">NotificationCenter</span>.removeObserver(<span class="keyword">_</span>:))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> method <span class="operator">=</span> class_getInstanceMethod(<span class="keyword">self</span>, selector)<span class="operator">!</span></span><br><span class="line">        <span class="keyword">let</span> newmethod <span class="operator">=</span> class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">#selector</span>(my_removeObserver(<span class="keyword">_</span>:)))</span><br><span class="line">        </span><br><span class="line">        method_exchangeImplementations(method, newmethod<span class="operator">!</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">my_removeObserver</span>(<span class="keyword">_</span> <span class="params">noti</span>: <span class="keyword">Any</span><span class="operator">?</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.my_removeObserver(noti)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Observer has been removed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们创建三个界面，分别为 <code>FirstController</code>、<code>SecondController</code> 和 <code>ThirdController</code>。</p><p>在 <code>FirstController</code> 的 <code>viewDidLoad</code> 方法中调用 <code>NotificationCenter.swizzling()</code>。</p><p>在 <code>SecondController</code> 中添加接收通知的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.default.addObserver(<span class="keyword">self</span>, selector: <span class="keyword">#selector</span>(notificationReceived), name: .<span class="keyword">init</span>(<span class="string">&quot;TestNotification&quot;</span>), object: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">notificationReceived</span>(<span class="keyword">_</span> <span class="params">noti</span>: <span class="type">Notification</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Has received notifciation by selector.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>ThirdController</code> 的 <code>viewDidLoad</code> 方法中发送通知：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.default.post(name: .<span class="keyword">init</span>(rawValue: <span class="string">&quot;TestNotification&quot;</span>), object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>此时便已万事俱备了，接下来开始我们的测试。</p><p>运行我们的 demo app，首先进入 <code>FirstController</code>，然后 present 出 <code>SecondController</code>，在第二个界面再次 present 出 <code>ThirdController</code>。</p><p>此时， <code>ThirdController</code> 中的通知消息已经发出，控制台也能看到输出了 “Has received notifciation by selector.”，此时将 <code>ThirdController</code> 关闭，控制台再次打印出 “Observer has been removed”。这说明 <code>ThirdController</code> 关闭的时候自动调用了 <code>removeObserver</code> 方法。<br>再将 <code>SecondController</code> 关闭，控制台同样打印出 “Observer has been removed”，这说明的确不用再手动移除通知的 <code>observer</code> 了。</p><h3 id="0x02-通知的-block-形式与-weak"><a href="#0x02-通知的-block-形式与-weak" class="headerlink" title="0x02 通知的 block 形式与 weak"></a>0x02 通知的 block 形式与 weak</h3><p>将 <code>SecondController</code> 中的接收通知代码替换为 block 形式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.default.addObserver(forName: .<span class="keyword">init</span>(<span class="string">&quot;TestNotification&quot;</span>), object: <span class="literal">nil</span>, queue: .main) &#123; (noti) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.notificationCallback(noti)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">notificationCallback</span>(<span class="keyword">_</span> <span class="params">noti</span>: <span class="type">Notification</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Has received notification by block.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再以相同的流程跑一遍，可以发现关闭 <code>SecondController</code> 并没有打印 “Observer has been removed”，是因为 <code>block</code> 形式的通知不支持自动移除吗？我们在 <code>deinit</code> 中手动移除一下再来看看。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Second view controller deinited.&quot;</span>)</span><br><span class="line">    <span class="type">NotificationCenter</span>.default.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再试一下，可以发现 <code>deinit</code> 方法根本没有调用，所以，根本原因其实是产生了循环引用导致不能正常释放。因此在 <code>block</code> 中添加weak，修改后的代码为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.default.addObserver(forName: .<span class="keyword">init</span>(<span class="string">&quot;TestNotification&quot;</span>), object: <span class="literal">nil</span>, queue: .main) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (noti) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span><span class="operator">?</span>.notificationCallback(noti)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Second view controller deinited.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行一遍我们的demo，可以看到控制台输出了 “Observer has been removed” 和 “Second view controller deinited.” 这两句话，证明了 <code>observer</code> 已正常移除，<code>SecondController</code> 也已正常释放。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>通过以上的测试，可以得出结论，在iOS 9.0，macOS 10.11 及以后的版本中，<code>NotificationCenter</code> 的 <code>observer</code> 不再需要手动移除，使用 <code>block</code> 形式的通知时，需要加上 <code>weak</code> 以避免循环引用的出现。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notification </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
